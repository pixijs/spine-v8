{"version":3,"file":"pixi-spine-pixi.mjs","sources":["../src/require-shim.ts","../src/SpineTexture.ts","../src/assets/atlasLoader.ts","../src/assets/skeletonLoader.ts","../src/darktint/DarkTintBatchGeometry.ts","../src/darktint/darkTintBit.ts","../src/darktint/DarkTintShader.ts","../src/darktint/DarkTintBatcher.ts","../src/BatchableSpineSlot.ts","../src/SpinePipe.ts","../src/Spine.ts","../src/SpineDebugRenderer.ts"],"sourcesContent":["/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\ndeclare global\n{\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    // eslint-disable-next-line no-var\n    var require: any;\n    // eslint-disable-next-line no-var\n    var PIXI: any;\n}\n\nif (typeof window !== 'undefined' && window.PIXI)\n{\n    const prevRequire = window.require;\n\n    // eslint-disable-next-line consistent-return\n    (window as any).require = (x: string) =>\n    {\n        if (prevRequire) return prevRequire(x);\n        else if (x.startsWith('@pixi/') || x.startsWith('pixi.js')) return window.PIXI;\n    };\n}\n\nexport { };\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Texture as PixiTexture } from 'pixi.js';\nimport { BlendMode, Texture, TextureFilter, TextureWrap } from '@esotericsoftware/spine-core';\n\nimport type { BLEND_MODES, SCALE_MODE, TextureSource, WRAP_MODE } from 'pixi.js';\n\nexport class SpineTexture extends Texture\n{\n    private static readonly textureMap: Map<TextureSource, SpineTexture> = new Map<TextureSource, SpineTexture>();\n\n    public static from(texture: TextureSource): SpineTexture\n    {\n        if (SpineTexture.textureMap.has(texture))\n        {\n            return SpineTexture.textureMap.get(texture) as SpineTexture;\n        }\n\n        return new SpineTexture(texture);\n    }\n\n    public readonly texture: PixiTexture;\n\n    private constructor(image: TextureSource)\n    {\n        // Todo: maybe add error handling if you feed a video texture to spine?\n        super(image.resource);\n        this.texture = PixiTexture.from(image);\n    }\n\n    public setFilters(minFilter: TextureFilter, magFilter: TextureFilter): void\n    {\n        const style = this.texture.source.style;\n\n        style.minFilter = SpineTexture.toPixiTextureFilter(minFilter);\n        style.magFilter = SpineTexture.toPixiTextureFilter(magFilter);\n        this.texture.source.autoGenerateMipmaps = SpineTexture.toPixiMipMap(minFilter);\n        this.texture.source.updateMipmaps();\n    }\n\n    public setWraps(uWrap: TextureWrap, vWrap: TextureWrap): void\n    {\n        const style = this.texture.source.style;\n\n        style.addressModeU = SpineTexture.toPixiTextureWrap(uWrap);\n        style.addressModeV = SpineTexture.toPixiTextureWrap(vWrap);\n    }\n\n    public dispose(): void\n    {\n        // I am not entirely sure about this...\n        this.texture.destroy();\n    }\n\n    private static toPixiMipMap(filter: TextureFilter): boolean\n    {\n        switch (filter)\n        {\n            case TextureFilter.Nearest:\n            case TextureFilter.Linear:\n                return false;\n\n            case TextureFilter.MipMapNearestLinear:\n            case TextureFilter.MipMapNearestNearest:\n            case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\n            case TextureFilter.MipMapLinearNearest:\n                return true;\n\n            default:\n                throw new Error(`Unknown texture filter: ${String(filter)}`);\n        }\n    }\n\n    private static toPixiTextureFilter(filter: TextureFilter): SCALE_MODE\n    {\n        switch (filter)\n        {\n            case TextureFilter.Nearest:\n            case TextureFilter.MipMapNearestLinear:\n            case TextureFilter.MipMapNearestNearest:\n                return 'nearest';\n\n            case TextureFilter.Linear:\n            case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\n            case TextureFilter.MipMapLinearNearest:\n                return 'linear';\n\n            default:\n                throw new Error(`Unknown texture filter: ${String(filter)}`);\n        }\n    }\n\n    private static toPixiTextureWrap(wrap: TextureWrap): WRAP_MODE\n    {\n        switch (wrap)\n        {\n            case TextureWrap.ClampToEdge:\n                return 'clamp-to-edge';\n\n            case TextureWrap.MirroredRepeat:\n                return 'mirror-repeat';\n\n            case TextureWrap.Repeat:\n                return 'repeat';\n\n            default:\n                throw new Error(`Unknown texture wrap: ${String(wrap)}`);\n        }\n    }\n\n    public static toPixiBlending(blend: BlendMode): BLEND_MODES\n    {\n        switch (blend)\n        {\n            case BlendMode.Normal:\n                return 'normal';\n\n            case BlendMode.Additive:\n                return 'add';\n\n            case BlendMode.Multiply:\n                return 'multiply';\n\n            case BlendMode.Screen:\n                return 'screen';\n\n            default:\n                throw new Error(`Unknown blendMode: ${String(blend)}`);\n        }\n    }\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n    checkExtension,\n    DOMAdapter,\n    extensions,\n    ExtensionType,\n    LoaderParserPriority,\n    path,\n    TextureSource\n} from 'pixi.js';\nimport { SpineTexture } from '../SpineTexture';\nimport { TextureAtlas } from '@esotericsoftware/spine-core';\n\nimport type { AssetExtension, Loader, ResolvedAsset, Texture } from 'pixi.js';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata> = {\n    extension: ExtensionType.Asset,\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spineTextureAtlasLoader',\n        },\n\n        test(url: string): boolean\n        {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas>\n        {\n            const response = await DOMAdapter.get().fetch(url);\n\n            const txt = await response.text();\n\n            return txt;\n        },\n\n        testParse(asset: unknown, options: ResolvedAsset): Promise<boolean>\n        {\n            const isExtensionRight = checkExtension(options.src as string, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        unload(atlas: TextureAtlas)\n        {\n            atlas.dispose();\n        },\n\n        async parse(asset: RawAtlas, options: ResolvedAsset, loader: Loader): Promise<TextureAtlas>\n        {\n            const metadata: ISpineAtlasMetadata = options.data || {};\n            let basePath = path.dirname(options.src as string);\n\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1)\n            {\n                basePath += '/';\n            }\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            const retval = new TextureAtlas(asset);\n\n            // If the user gave me only one texture, that one is assumed to be the \"first\" texture in the atlas\n            if (metadata.images instanceof TextureSource || typeof metadata.images === 'string')\n            {\n                const pixiTexture = metadata.images;\n\n                metadata.images = {} as Record<string, TextureSource | string>;\n                metadata.images[retval.pages[0].name] = pixiTexture;\n            }\n\n            // we will wait for all promises for the textures at the same time at the end.\n            const textureLoadingPromises:Promise<any>[] = [];\n\n            // fill the pages\n            for (const page of retval.pages)\n            {\n                const pageName = page.name;\n                const providedPage = metadata?.images ? metadata.images[pageName] : undefined;\n\n                if (providedPage instanceof TextureSource)\n                {\n                    page.setTexture(SpineTexture.from(providedPage));\n                }\n                else\n                {\n                    // eslint-disable-next-line max-len\n                    const url: string = providedPage ?? path.normalize([...basePath.split(path.sep), pageName].join(path.sep));\n\n                    const assetsToLoadIn = {\n                        src: url,\n                        data: {\n                            ...metadata.imageMetadata,\n                            alphaMode: page.pma ? 'premultiplied-alpha' : 'premultiply-alpha-on-upload'\n                        }\n                    };\n\n                    const pixiPromise = loader.load<Texture>(assetsToLoadIn).then((texture) =>\n                    {\n                        page.setTexture(SpineTexture.from(texture.source));\n                    });\n\n                    textureLoadingPromises.push(pixiPromise);\n                }\n            }\n\n            await Promise.all(textureLoadingPromises);\n\n            return retval;\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata>;\n\nextensions.add(spineTextureAtlasLoader);\n\nexport interface ISpineAtlasMetadata\n{\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\n    imageMetadata?: any;\n    // If you already have atlas pages loaded as pixi textures\n    // and want to use that to create the atlas, you can pass them here\n    images?: TextureSource | string | Record<string, TextureSource | string>;\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n    type AssetExtension,\n    checkExtension,\n    DOMAdapter,\n    extensions,\n    ExtensionType,\n    LoaderParserPriority,\n    ResolvedAsset\n} from 'pixi.js';\n\ntype SkeletonJsonAsset = any;\ntype SkeletonBinaryAsset = Uint8Array;\n\nfunction isJson(resource: any): resource is SkeletonJsonAsset\n{\n    return Object.prototype.hasOwnProperty.call(resource, 'bones');\n}\n\nfunction isBuffer(resource: any): resource is SkeletonBinaryAsset\n{\n    return resource instanceof Uint8Array;\n}\n\nconst spineLoaderExtension: AssetExtension<SkeletonJsonAsset | SkeletonBinaryAsset> = {\n    extension: ExtensionType.Asset,\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spineSkeletonLoader',\n        },\n\n        test(url)\n        {\n            return checkExtension(url, '.skel');\n        },\n\n        async load(url: string): Promise<SkeletonBinaryAsset>\n        {\n            const response = await DOMAdapter.get().fetch(url);\n\n            const buffer = new Uint8Array(await response.arrayBuffer());\n\n            return buffer;\n        },\n        testParse(asset: unknown, options: ResolvedAsset): Promise<boolean>\n        {\n            const isJsonSpineModel = checkExtension(options.src, '.json') && isJson(asset);\n            const isBinarySpineModel = checkExtension(options.src, '.skel') && isBuffer(asset);\n\n            return Promise.resolve(isJsonSpineModel || isBinarySpineModel);\n        },\n    },\n} as AssetExtension<SkeletonJsonAsset | SkeletonBinaryAsset>;\n\nextensions.add(spineLoaderExtension);\n","import { Buffer, BufferUsage, Geometry } from 'pixi.js';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class DarkTintBatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 7;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aDarkColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 5 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 6 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n","/* eslint-disable max-len */\nexport const darkTintBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aDarkColor: vec4<f32>;\n            @out vDarkColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n        vDarkColor = aDarkColor;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @in vDarkColor: vec4<f32>;\n        `,\n        end: /* wgsl */`\n            \n        let alpha = outColor.a * vColor.a;\n        let rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;\n\n        finalColor = vec4<f32>(rgb, alpha);\n\n        `\n    }\n};\n\nexport const darkTintBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aDarkColor;\n            out vec4 vDarkColor;\n        `,\n        main: /* glsl */`\n            vDarkColor = aDarkColor;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            in vec4 vDarkColor;\n        `,\n        end: /* glsl */`\n            \n        finalColor.a = outColor.a * vColor.a;\n        finalColor.rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;\n        `\n    }\n};\n","import {\n    colorBit,\n    colorBitGl,\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram,\n    generateTextureBatchBit,\n    generateTextureBatchBitGl,\n    getBatchSamplersUniformGroup,\n    roundPixelsBit,\n    roundPixelsBitGl,\n    Shader\n} from 'pixi.js';\nimport { darkTintBit, darkTintBitGl } from './darkTintBit';\n\nexport class DarkTintShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'dark-tint-batch',\n            bits: [\n                colorBitGl,\n                darkTintBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'dark-tint-batch',\n            bits: [\n                colorBit,\n                darkTintBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import {\n    Batcher,\n    Color,\n    DefaultBatchableMeshElement,\n    DefaultBatchableQuadElement,\n    extensions,\n    ExtensionType,\n    Shader\n} from 'pixi.js';\nimport { DarkTintBatchGeometry } from './DarkTintBatchGeometry';\nimport { DarkTintShader } from './DarkTintShader';\n\nlet defaultShader: Shader = null;\n\n/** The default batcher is used to batch quads and meshes. */\nexport class DarkTintBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'darkTint',\n    } as const;\n\n    public geometry = new DarkTintBatchGeometry();\n    public shader = defaultShader || (defaultShader = new DarkTintShader(this.maxTextures));\n    public name = DarkTintBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, darkColor, textureIdAndRound -> total = 7 */\n    public vertexSize = 7;\n\n    public packAttributes(\n        element: DefaultBatchableMeshElement & { darkColor: number },\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n        const worldAlpha = ((argb >> 24) & 0xFF) / 255;\n        const darkColor = Color.shared.setValue(element.darkColor).premultiply(worldAlpha, true).toPremultiplied(1, false);\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = darkColor;\n\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement & { darkColor: number },\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n        const darkColor = element.darkColor;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = darkColor;\n        uint32View[index + 6] = textureIdAndRound;\n\n        // xy\n        float32View[index + 7] = (a * w0) + (c * h1) + tx;\n        float32View[index + 8] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 9] = uvs.x1;\n        float32View[index + 10] = uvs.y1;\n\n        uint32View[index + 11] = argb;\n        uint32View[index + 12] = darkColor;\n        uint32View[index + 13] = textureIdAndRound;\n\n        // xy\n        float32View[index + 14] = (a * w0) + (c * h0) + tx;\n        float32View[index + 15] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 16] = uvs.x2;\n        float32View[index + 17] = uvs.y2;\n\n        uint32View[index + 18] = argb;\n        uint32View[index + 19] = darkColor;\n        uint32View[index + 20] = textureIdAndRound;\n\n        // xy\n        float32View[index + 21] = (a * w1) + (c * h0) + tx;\n        float32View[index + 22] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 23] = uvs.x3;\n        float32View[index + 24] = uvs.y3;\n\n        uint32View[index + 25] = argb;\n        uint32View[index + 26] = darkColor;\n        uint32View[index + 27] = textureIdAndRound;\n    }\n}\n\nextensions.add(DarkTintBatcher);\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { AttachmentCacheData, Spine } from './Spine';\n\nimport type { Batch, Batcher, BLEND_MODES, DefaultBatchableMeshElement, Matrix, Texture } from 'pixi.js';\n\nexport class BatchableSpineSlot implements DefaultBatchableMeshElement\n{\n    indexOffset = 0;\n    attributeOffset = 0;\n\n    indexSize: number;\n    attributeSize: number;\n\n    batcherName = 'darkTint';\n\n    readonly packAsQuad = false;\n\n    renderable: Spine;\n\n    positions: Float32Array;\n    indices: number[] | Uint16Array;\n    uvs: Float32Array;\n\n    roundPixels: 0 | 1;\n    data: AttachmentCacheData;\n    blendMode: BLEND_MODES;\n\n    darkTint: number;\n\n    texture: Texture;\n\n    transform: Matrix;\n\n    // used internally by batcher specific..\n    // stored for efficient updating..\n    _textureId: number;\n    _attributeStart: number;\n    _indexStart: number;\n    _batcher: Batcher;\n    _batch: Batch;\n\n    get color()\n    {\n        const slotColor = this.data.color;\n\n        const parentColor:number = this.renderable.groupColor;\n        const parentAlpha:number = this.renderable.groupAlpha;\n        let abgr:number;\n\n        const mixedA = (slotColor.a * parentAlpha) * 255;\n\n        if (parentColor !== 0xFFFFFF)\n        {\n            const parentB = (parentColor >> 16) & 0xFF;\n            const parentG = (parentColor >> 8) & 0xFF;\n            const parentR = parentColor & 0xFF;\n\n            const mixedR = (slotColor.r * parentR);\n            const mixedG = (slotColor.g * parentG);\n            const mixedB = (slotColor.b * parentB);\n\n            abgr = ((mixedA) << 24) | (mixedB << 16) | (mixedG << 8) | mixedR;\n        }\n        else\n        {\n            abgr = ((mixedA) << 24) | ((slotColor.b * 255) << 16) | ((slotColor.g * 255) << 8) | (slotColor.r * 255);\n        }\n\n        return abgr;\n    }\n\n    get darkColor()\n    {\n        const darkColor = this.data.darkColor;\n\n        return ((darkColor.b * 255) << 16) | ((darkColor.g * 255) << 8) | (darkColor.r * 255);\n    }\n\n    get groupTransform() { return this.renderable.groupTransform; }\n\n    setData(\n        renderable:Spine,\n        data:AttachmentCacheData,\n        blendMode:BLEND_MODES,\n        roundPixels: 0 | 1)\n    {\n        this.renderable = renderable;\n        this.transform = renderable.groupTransform;\n        this.data = data;\n\n        if (data.clipped)\n        {\n            const clippedData = data.clippedData;\n\n            this.indexSize = clippedData.indicesCount;\n            this.attributeSize = clippedData.vertexCount;\n            this.positions = clippedData.vertices;\n            this.indices = clippedData.indices;\n            this.uvs = clippedData.uvs;\n        }\n        else\n        {\n            this.indexSize = data.indices.length;\n            this.attributeSize = data.vertices.length / 2;\n            this.positions = data.vertices;\n            this.indices = data.indices;\n            this.uvs = data.uvs;\n        }\n\n        this.texture = data.texture;\n        this.roundPixels = roundPixels;\n\n        this.blendMode = blendMode;\n\n        this.batcherName = data.darkTint ? 'darkTint' : 'default';\n    }\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n    collectAllRenderables,\n    extensions, ExtensionType,\n    InstructionSet,\n    type Renderer,\n    type RenderPipe,\n} from 'pixi.js';\nimport { BatchableSpineSlot } from './BatchableSpineSlot';\nimport { Spine } from './Spine';\nimport { MeshAttachment, RegionAttachment, SkeletonClipping } from '@esotericsoftware/spine-core';\n\nconst clipper = new SkeletonClipping();\n\nconst spineBlendModeMap = {\n    0: 'normal',\n    1: 'add',\n    2: 'multiply',\n    3: 'screen'\n};\n\n// eslint-disable-next-line max-len\nexport class SpinePipe implements RenderPipe<Spine>\n{\n    /** @ignore */\n    static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'spine',\n    } as const;\n\n    renderer: Renderer;\n\n    private gpuSpineData:Record<string, any> = {};\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    validateRenderable(spine: Spine): boolean\n    {\n        spine._applyState();\n\n        // if pine attachments have changed, we need to rebuild the batch!\n        if (spine.spineAttachmentsDirty)\n        {\n            return true;\n        }\n        // if the textures have changed, we need to rebuild the batch, but only if the texture is not already in the batch\n        else if (spine.spineTexturesDirty)\n        {\n            // loop through and see if the textures have changed..\n            const drawOrder = spine.skeleton.drawOrder;\n            const gpuSpine = this.gpuSpineData[spine.uid];\n\n            for (let i = 0, n = drawOrder.length; i < n; i++)\n            {\n                const slot = drawOrder[i];\n                const attachment = slot.getAttachment();\n\n                if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\n                {\n                    const cacheData = spine._getCachedData(slot, attachment);\n                    const batchableSpineSlot = gpuSpine.slotBatches[cacheData.id];\n\n                    const texture = cacheData.texture;\n\n                    if (texture !== batchableSpineSlot.texture)\n                    {\n                        if (!batchableSpineSlot._batcher.checkAndUpdateTexture(batchableSpineSlot, texture))\n                        {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    addRenderable(spine: Spine, instructionSet:InstructionSet)\n    {\n        const gpuSpine = this.gpuSpineData[spine.uid] ||= { slotBatches: {} };\n\n        const batcher = this.renderer.renderPipes.batch;\n\n        const drawOrder = spine.skeleton.drawOrder;\n\n        const roundPixels = (this.renderer._roundPixels | spine._roundPixels) as 0 | 1;\n\n        spine._applyState();\n\n        for (let i = 0, n = drawOrder.length; i < n; i++)\n        {\n            const slot = drawOrder[i];\n            const attachment = slot.getAttachment();\n            const blendMode = spineBlendModeMap[slot.data.blendMode];\n\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\n            {\n                const cacheData = spine._getCachedData(slot, attachment);\n                const batchableSpineSlot = gpuSpine.slotBatches[cacheData.id] ||= new BatchableSpineSlot();\n\n                batchableSpineSlot.setData(\n                    spine,\n                    cacheData,\n                    blendMode,\n                    roundPixels\n                );\n\n                if (!cacheData.skipRender)\n                {\n                    batcher.addToBatch(batchableSpineSlot, instructionSet);\n                }\n            }\n\n            const containerAttachment = spine._slotsObject[slot.data.name];\n\n            if (containerAttachment)\n            {\n                const container = containerAttachment.container;\n\n                container.includeInBuild = true;\n                collectAllRenderables(container, instructionSet, this.renderer);\n                container.includeInBuild = false;\n            }\n        }\n\n        clipper.clipEnd();\n    }\n\n    updateRenderable(spine: Spine)\n    {\n        // we assume that spine will always change its verts size..\n        const gpuSpine = this.gpuSpineData[spine.uid];\n\n        spine._applyState();\n\n        const drawOrder = spine.skeleton.drawOrder;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++)\n        {\n            const slot = drawOrder[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\n            {\n                const cacheData = spine._getCachedData(slot, attachment);\n\n                if (!cacheData.skipRender)\n                {\n                    const batchableSpineSlot = gpuSpine.slotBatches[spine._getCachedData(slot, attachment).id];\n\n                    batchableSpineSlot._batcher?.updateElement(batchableSpineSlot);\n                }\n            }\n        }\n    }\n\n    destroyRenderable(spine: Spine)\n    {\n        // TODO remove the renderable from the batcher\n        this.gpuSpineData[spine.uid] = null as any;\n    }\n\n    destroy()\n    {\n        this.gpuSpineData = null as any;\n        this.renderer = null as any;\n    }\n}\n\nextensions.add(SpinePipe);\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n    Assets,\n    Bounds,\n    Cache,\n    Container,\n    ContainerOptions,\n    DEG_TO_RAD,\n    DestroyOptions,\n    PointData,\n    Texture,\n    Ticker,\n    ViewContainer,\n} from 'pixi.js';\nimport { ISpineDebugRenderer } from './SpineDebugRenderer';\nimport {\n    AnimationState,\n    AnimationStateData,\n    AtlasAttachmentLoader,\n    Attachment,\n    Bone,\n    ClippingAttachment,\n    Color,\n    MeshAttachment,\n    Physics,\n    RegionAttachment,\n    Skeleton,\n    SkeletonBinary,\n    SkeletonBounds,\n    SkeletonClipping,\n    SkeletonData,\n    SkeletonJson,\n    Slot,\n    type TextureAtlas,\n    TrackEntry,\n    Vector2,\n} from '@esotericsoftware/spine-core';\n\nexport type SpineFromOptions = {\n    skeleton: string;\n    atlas: string;\n    scale?: number;\n};\n\nconst vectorAux = new Vector2();\nconst lightColor = new Color();\nconst darkColor = new Color();\n\nSkeleton.yDown = true;\n\nconst clipper = new SkeletonClipping();\n\nexport interface SpineOptions extends ContainerOptions\n{\n    skeletonData: SkeletonData;\n    autoUpdate?: boolean;\n}\n\nexport interface SpineEvents\n{\n    complete: [trackEntry: TrackEntry];\n    dispose: [trackEntry: TrackEntry];\n    end: [trackEntry: TrackEntry];\n    event: [trackEntry: TrackEntry, event: Event];\n    interrupt: [trackEntry: TrackEntry];\n    start: [trackEntry: TrackEntry];\n}\n\nexport interface AttachmentCacheData\n{\n    id: string;\n    clipped: boolean;\n    vertices: Float32Array;\n    uvs: Float32Array;\n    indices: number[];\n    color: Color;\n    darkColor: Color | null;\n    darkTint: boolean;\n    skipRender: boolean;\n    texture: Texture;\n    clippedData?: {\n        vertices: Float32Array;\n        uvs: Float32Array;\n        indices: Uint16Array;\n        vertexCount: number;\n        indicesCount: number;\n    };\n}\n\nexport class Spine extends ViewContainer\n{\n    // Pixi properties\n    public batched = true;\n    public buildId = 0;\n    public override readonly renderPipeId = 'spine';\n    public _didSpineUpdate = false;\n\n    public beforeUpdateWorldTransforms: (object: Spine) => void = () => { /** */ };\n    public afterUpdateWorldTransforms: (object: Spine) => void = () => { /** */ };\n\n    // Spine properties\n    public skeleton: Skeleton;\n    public state: AnimationState;\n    public skeletonBounds: SkeletonBounds;\n    private _debug?: ISpineDebugRenderer | undefined = undefined;\n\n    readonly _slotsObject: Record<string, {slot:Slot, container:Container}> = Object.create(null);\n\n    private getSlotFromRef(slotRef: number | string | Slot): Slot\n    {\n        let slot: Slot | null;\n\n        if (typeof slotRef === 'number') slot = this.skeleton.slots[slotRef];\n        else if (typeof slotRef === 'string') slot = this.skeleton.findSlot(slotRef);\n        else slot = slotRef;\n\n        if (!slot) throw new Error(`No slot found with the given slot reference: ${slotRef}`);\n\n        return slot;\n    }\n\n    public spineAttachmentsDirty = true;\n    public spineTexturesDirty = true;\n\n    private _lastAttachments: Attachment[];\n\n    private _stateChanged = true;\n    private attachmentCacheData: Record<string, AttachmentCacheData>[] = [];\n\n    public get debug(): ISpineDebugRenderer | undefined\n    {\n        return this._debug;\n    }\n\n    public set debug(value: ISpineDebugRenderer | undefined)\n    {\n        if (this._debug)\n        {\n            this._debug.unregisterSpine(this);\n        }\n        if (value)\n        {\n            value.registerSpine(this);\n        }\n        this._debug = value;\n    }\n\n    private autoUpdateWarned = false;\n    private _autoUpdate = true;\n\n    public get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    public set autoUpdate(value: boolean)\n    {\n        if (value)\n        {\n            Ticker.shared.add(this.internalUpdate, this);\n            this.autoUpdateWarned = false;\n        }\n        else\n        {\n            Ticker.shared.remove(this.internalUpdate, this);\n        }\n\n        this._autoUpdate = value;\n    }\n\n    constructor(options: SpineOptions | SkeletonData)\n    {\n        if (options instanceof SkeletonData)\n        {\n            options = {\n                skeletonData: options,\n            };\n        }\n\n        super();\n\n        const skeletonData = options instanceof SkeletonData ? options : options.skeletonData;\n\n        this.skeleton = new Skeleton(skeletonData);\n        this.state = new AnimationState(new AnimationStateData(skeletonData));\n        this.autoUpdate = options?.autoUpdate ?? true;\n\n        const slots = this.skeleton.slots;\n\n        for (let i = 0; i < slots.length; i++)\n        {\n            this.attachmentCacheData[i] = Object.create(null);\n        }\n\n        this._updateState(0);\n    }\n\n    public update(dt: number): void\n    {\n        if (this.autoUpdate && !this.autoUpdateWarned)\n        {\n            console.warn(\n                // eslint-disable-next-line max-len\n                'You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want.',\n            );\n            this.autoUpdateWarned = true;\n        }\n\n        this.internalUpdate(0, dt);\n    }\n\n    protected internalUpdate(_deltaFrame: any, deltaSeconds?: number): void\n    {\n        // Because reasons, pixi uses deltaFrames at 60fps.\n        // We ignore the default deltaFrames and use the deltaSeconds from pixi ticker.\n        this._updateState(deltaSeconds ?? Ticker.shared.deltaMS / 1000);\n    }\n\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this.updateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    public setBonePosition(bone: string | Bone, position: PointData): void\n    {\n        const boneAux = bone;\n\n        if (typeof bone === 'string')\n        {\n            bone = this.skeleton.findBone(bone) as Bone;\n        }\n\n        if (!bone) throw Error(`Cant set bone position, bone ${String(boneAux)} not found`);\n        vectorAux.set(position.x, position.y);\n\n        if (bone.parent)\n        {\n            const aux = bone.parent.worldToLocal(vectorAux);\n\n            bone.x = aux.x;\n            bone.y = -aux.y;\n        }\n        else\n        {\n            bone.x = vectorAux.x;\n            bone.y = vectorAux.y;\n        }\n    }\n\n    public getBonePosition(bone: string | Bone, outPos?: PointData): PointData | undefined\n    {\n        const boneAux = bone;\n\n        if (typeof bone === 'string')\n        {\n            bone = this.skeleton.findBone(bone) as Bone;\n        }\n\n        if (!bone)\n        {\n            console.error(`Cant set bone position! Bone ${String(boneAux)} not found`);\n\n            return outPos;\n        }\n\n        if (!outPos)\n        {\n            outPos = { x: 0, y: 0 };\n        }\n\n        outPos.x = bone.worldX;\n        outPos.y = bone.worldY;\n\n        return outPos;\n    }\n\n    /**\n     * Will update the state based on the specified time, this will not apply the state to the skeleton\n     * as this is differed until the `applyState` method is called.\n     *\n     * @param time the time at which to set the state\n     * @internal\n     */\n    _updateState(time: number)\n    {\n        this.state.update(time);\n        this.skeleton.update(time);\n\n        this._stateChanged = true;\n\n        this._boundsDirty = true;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Applies the state to this spine instance.\n     * - updates the state to the skeleton\n     * - updates its world transform (spine world transform)\n     * - validates the attachments - to flag if the attachments have changed this state\n     * - transforms the attachments - to update the vertices of the attachments based on the new positions\n     * - update the slot attachments - to update the position, rotation, scale, and visibility of the attached containers\n     * @internal\n     */\n    _applyState()\n    {\n        if (!this._stateChanged) return;\n        this._stateChanged = false;\n\n        const { skeleton } = this;\n\n        this.state.apply(skeleton);\n\n        this.beforeUpdateWorldTransforms(this);\n        skeleton.updateWorldTransform(Physics.update);\n        this.afterUpdateWorldTransforms(this);\n\n        this.validateAttachments();\n\n        this.transformAttachments();\n\n        this.updateSlotObjects();\n    }\n\n    private validateAttachments()\n    {\n        const currentDrawOrder = this.skeleton.drawOrder;\n\n        const lastAttachments = (this._lastAttachments ||= []);\n\n        let index = 0;\n\n        let spineAttachmentsDirty = false;\n\n        for (let i = 0; i < currentDrawOrder.length; i++)\n        {\n            const slot = currentDrawOrder[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment)\n            {\n                if (attachment !== lastAttachments[index])\n                {\n                    spineAttachmentsDirty = true;\n                    lastAttachments[index] = attachment;\n                }\n\n                index++;\n            }\n        }\n\n        if (index !== lastAttachments.length)\n        {\n            spineAttachmentsDirty = true;\n            lastAttachments.length = index;\n        }\n\n        this.spineAttachmentsDirty = spineAttachmentsDirty;\n    }\n\n    private transformAttachments()\n    {\n        const currentDrawOrder = this.skeleton.drawOrder;\n\n        for (let i = 0; i < currentDrawOrder.length; i++)\n        {\n            const slot = currentDrawOrder[i];\n\n            const attachment = slot.getAttachment();\n\n            if (attachment)\n            {\n                if (attachment instanceof MeshAttachment || attachment instanceof RegionAttachment)\n                {\n                    const cacheData = this._getCachedData(slot, attachment);\n\n                    if (attachment instanceof RegionAttachment)\n                    {\n                        attachment.computeWorldVertices(slot, cacheData.vertices, 0, 2);\n                    }\n                    else\n                    {\n                        attachment.computeWorldVertices(\n                            slot,\n                            0,\n                            attachment.worldVerticesLength,\n                            cacheData.vertices,\n                            0,\n                            2,\n                        );\n                    }\n\n                    cacheData.uvs = attachment.uvs as Float32Array;\n\n                    const skeleton = slot.bone.skeleton;\n                    const skeletonColor = skeleton.color;\n                    const slotColor = slot.color;\n\n                    const attachmentColor = attachment.color;\n\n                    cacheData.color.set(\n                        skeletonColor.r * slotColor.r * attachmentColor.r,\n                        skeletonColor.g * slotColor.g * attachmentColor.g,\n                        skeletonColor.b * slotColor.b * attachmentColor.b,\n                        skeletonColor.a * slotColor.a * attachmentColor.a,\n                    );\n\n                    cacheData.darkTint = !!slot.darkColor;\n\n                    if (slot.darkColor)\n                    {\n                        cacheData.darkColor.setFromColor(slot.darkColor);\n                    }\n\n                    cacheData.skipRender = cacheData.clipped = false;\n\n                    const texture = attachment.region?.texture.texture || Texture.EMPTY;\n\n                    if (cacheData.texture !== texture)\n                    {\n                        cacheData.texture = texture;\n                        this.spineTexturesDirty = true;\n                    }\n\n                    if (clipper.isClipping())\n                    {\n                        this.updateClippingData(cacheData);\n                    }\n                }\n                else if (attachment instanceof ClippingAttachment)\n                {\n                    clipper.clipStart(slot, attachment);\n                    continue;\n                }\n            }\n            clipper.clipEndWithSlot(slot);\n        }\n        clipper.clipEnd();\n    }\n\n    private updateClippingData(cacheData: AttachmentCacheData)\n    {\n        cacheData.clipped = true;\n\n        clipper.clipTriangles(\n            cacheData.vertices,\n            cacheData.vertices.length,\n            cacheData.indices,\n            cacheData.indices.length,\n            cacheData.uvs,\n            lightColor,\n            darkColor,\n            false,\n        );\n\n        const { clippedVertices, clippedTriangles } = clipper;\n\n        const verticesCount = clippedVertices.length / 8;\n        const indicesCount = clippedTriangles.length;\n\n        if (!cacheData.clippedData)\n        {\n            cacheData.clippedData = {\n                vertices: new Float32Array(verticesCount * 2),\n                uvs: new Float32Array(verticesCount * 2),\n                vertexCount: verticesCount,\n                indices: new Uint16Array(indicesCount),\n                indicesCount,\n            };\n\n            this.spineAttachmentsDirty = true;\n        }\n\n        const clippedData = cacheData.clippedData;\n\n        const sizeChange = clippedData.vertexCount !== verticesCount || indicesCount !== clippedData.indicesCount;\n\n        cacheData.skipRender = verticesCount === 0;\n\n        if (sizeChange)\n        {\n            this.spineAttachmentsDirty = true;\n\n            if (clippedData.vertexCount < verticesCount)\n            {\n                // buffer reuse!\n                clippedData.vertices = new Float32Array(verticesCount * 2);\n                clippedData.uvs = new Float32Array(verticesCount * 2);\n            }\n\n            if (clippedData.indices.length < indicesCount)\n            {\n                clippedData.indices = new Uint16Array(indicesCount);\n            }\n        }\n\n        const { vertices, uvs, indices } = clippedData;\n\n        for (let i = 0; i < verticesCount; i++)\n        {\n            vertices[i * 2] = clippedVertices[i * 8];\n            vertices[(i * 2) + 1] = clippedVertices[(i * 8) + 1];\n\n            uvs[i * 2] = clippedVertices[(i * 8) + 6];\n            uvs[(i * 2) + 1] = clippedVertices[(i * 8) + 7];\n        }\n\n        clippedData.vertexCount = verticesCount;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indices[i] = clippedTriangles[i];\n        }\n\n        clippedData.indicesCount = indicesCount;\n    }\n\n    /**\n     * ensure that attached containers map correctly to their slots\n     * along with their position, rotation, scale, and visibility.\n     */\n    private updateSlotObjects()\n    {\n        for (const i in this._slotsObject)\n        {\n            const slotAttachment = this._slotsObject[i];\n\n            if (!slotAttachment) continue;\n\n            this.updateSlotObject(slotAttachment);\n        }\n    }\n\n    private updateSlotObject(slotAttachment: {slot:Slot, container:Container})\n    {\n        const { slot, container } = slotAttachment;\n\n        container.visible = this.skeleton.drawOrder.includes(slot);\n\n        if (container.visible)\n        {\n            const bone = slot.bone;\n\n            container.position.set(bone.worldX, bone.worldY);\n\n            container.scale.x = bone.getWorldScaleX();\n            container.scale.y = bone.getWorldScaleY();\n\n            container.rotation = bone.getWorldRotationX() * DEG_TO_RAD;\n        }\n    }\n\n    /** @internal */\n    _getCachedData(slot: Slot, attachment: RegionAttachment | MeshAttachment): AttachmentCacheData\n    {\n        return this.attachmentCacheData[slot.data.index][attachment.name] || this.initCachedData(slot, attachment);\n    }\n\n    private initCachedData(slot: Slot, attachment: RegionAttachment | MeshAttachment): AttachmentCacheData\n    {\n        let vertices: Float32Array;\n\n        if (attachment instanceof RegionAttachment)\n        {\n            vertices = new Float32Array(8);\n\n            this.attachmentCacheData[slot.data.index][attachment.name] = {\n                id: `${slot.data.index}-${attachment.name}`,\n                vertices,\n                clipped: false,\n                indices: [0, 1, 2, 0, 2, 3],\n                uvs: attachment.uvs as Float32Array,\n                color: new Color(1, 1, 1, 1),\n                darkColor: new Color(0, 0, 0, 0),\n                darkTint: false,\n                skipRender: false,\n                texture: attachment.region?.texture.texture,\n            };\n        }\n        else\n        {\n            vertices = new Float32Array(attachment.worldVerticesLength);\n\n            this.attachmentCacheData[slot.data.index][attachment.name] = {\n                id: `${slot.data.index}-${attachment.name}`,\n                vertices,\n                clipped: false,\n                indices: attachment.triangles,\n                uvs: attachment.uvs as Float32Array,\n                color: new Color(1, 1, 1, 1),\n                darkColor: new Color(0, 0, 0, 0),\n                darkTint: false,\n                skipRender: false,\n                texture: attachment.region?.texture.texture,\n            };\n        }\n\n        return this.attachmentCacheData[slot.data.index][attachment.name];\n    }\n\n    protected onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n\n        this.debug?.renderDebug(this);\n    }\n\n    /**\n     * Attaches a PixiJS container to a specified slot. This will map the world transform of the slots bone\n     * to the attached container. A container can only be attached to one slot at a time.\n     *\n     * @param container - The container to attach to the slot\n     * @param slotRef - The slot id or  slot to attach to\n     */\n    public addSlotObject(slot: number | string | Slot, container: Container)\n    {\n        slot = this.getSlotFromRef(slot);\n\n        // need to check in on the container too...\n        for (const i in this._slotsObject)\n        {\n            if (this._slotsObject[i]?.container === container)\n            {\n                this.removeSlotObject(this._slotsObject[i].slot);\n            }\n        }\n\n        this.removeSlotObject(slot);\n\n        container.includeInBuild = false;\n\n        // TODO only add once??\n        this.addChild(container);\n\n        this._slotsObject[slot.data.name] = {\n            container,\n            slot\n        };\n\n        this.updateSlotObject(this._slotsObject[slot.data.name]);\n    }\n\n    /**\n     * Removes a PixiJS container from the slot it is attached to.\n     *\n     * @param container - The container to detach from the slot\n     * @param slotOrContainer - The container, slot id or slot to detach from\n     */\n    public removeSlotObject(slotOrContainer: number | string | Slot | Container)\n    {\n        let containerToRemove: Container | undefined;\n\n        if (slotOrContainer instanceof Container)\n        {\n            for (const i in this._slotsObject)\n            {\n                if (this._slotsObject[i]?.container === slotOrContainer)\n                {\n                    this._slotsObject[i] = null;\n\n                    containerToRemove = slotOrContainer;\n                    break;\n                }\n            }\n        }\n        else\n        {\n            const slot = this.getSlotFromRef(slotOrContainer);\n\n            containerToRemove = this._slotsObject[slot.data.name]?.container;\n            this._slotsObject[slot.data.name] = null;\n        }\n\n        if (containerToRemove)\n        {\n            this.removeChild(containerToRemove);\n\n            containerToRemove.includeInBuild = true;\n        }\n    }\n\n    /**\n     * Returns a container attached to a slot, or undefined if no container is attached.\n     *\n     * @param slotRef - The slot id or slot to get the attachment from\n     * @returns - The container attached to the slot\n     */\n    public getSlotObject(slot: number | string | Slot)\n    {\n        slot = this.getSlotFromRef(slot);\n\n        return this._slotsObject[slot.data.name].container;\n    }\n\n    private updateBounds()\n    {\n        this._boundsDirty = false;\n\n        this.skeletonBounds ||= new SkeletonBounds();\n\n        const skeletonBounds = this.skeletonBounds;\n\n        skeletonBounds.update(this.skeleton, true);\n\n        if (skeletonBounds.minX === Infinity)\n        {\n            this._applyState();\n\n            const drawOrder = this.skeleton.drawOrder;\n            const bounds = this._bounds;\n\n            bounds.clear();\n\n            for (let i = 0; i < drawOrder.length; i++)\n            {\n                const slot = drawOrder[i];\n\n                const attachment = slot.getAttachment();\n\n                if (attachment && (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment))\n                {\n                    const cacheData = this._getCachedData(slot, attachment);\n\n                    bounds.addVertexData(cacheData.vertices, 0, cacheData.vertices.length);\n                }\n            }\n        }\n        else\n        {\n            this._bounds.minX = skeletonBounds.minX;\n            this._bounds.minY = skeletonBounds.minY;\n            this._bounds.maxX = skeletonBounds.maxX;\n            this._bounds.maxY = skeletonBounds.maxY;\n        }\n    }\n\n    /** @internal */\n    addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this.bounds);\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        Ticker.shared.remove(this.internalUpdate, this);\n        this.state.clearListeners();\n        this.debug = undefined;\n        this.skeleton = null as any;\n        this.state = null as any;\n        (this._slotsObject as any) = null;\n        this._lastAttachments = null;\n        this.attachmentCacheData = null as any;\n    }\n\n    /** Converts a point from the skeleton coordinate system to the Pixi world coordinate system. */\n    public skeletonToPixiWorldCoordinates(point: { x: number; y: number })\n    {\n        this.worldTransform.apply(point, point);\n    }\n\n    /** Converts a point from the Pixi world coordinate system to the skeleton coordinate system. */\n    public pixiWorldCoordinatesToSkeleton(point: { x: number; y: number })\n    {\n        this.worldTransform.applyInverse(point, point);\n    }\n\n    /** Converts a point from the Pixi world coordinate system to the bone's local coordinate system. */\n    public pixiWorldCoordinatesToBone(point: { x: number; y: number }, bone: Bone)\n    {\n        this.pixiWorldCoordinatesToSkeleton(point);\n        if (bone.parent)\n        {\n            bone.parent.worldToLocal(point as Vector2);\n        }\n        else\n        {\n            bone.worldToLocal(point as Vector2);\n        }\n    }\n\n    static from({ skeleton, atlas, scale = 1 }: SpineFromOptions)\n    {\n        const cacheKey = `${skeleton}-${atlas}-${scale}`;\n\n        if (Cache.has(cacheKey))\n        {\n            return new Spine(Cache.get<SkeletonData>(cacheKey));\n        }\n\n        const skeletonAsset = Assets.get<any | Uint8Array>(skeleton);\n\n        const atlasAsset = Assets.get<TextureAtlas>(atlas);\n        const attachmentLoader = new AtlasAttachmentLoader(atlasAsset);\n        // eslint-disable-next-line max-len\n        const parser\n            = skeletonAsset instanceof Uint8Array\n                ? new SkeletonBinary(attachmentLoader)\n                : new SkeletonJson(attachmentLoader);\n\n        // TODO scale?\n        parser.scale = scale;\n        const skeletonData = parser.readSkeletonData(skeletonAsset);\n\n        Cache.set(cacheKey, skeletonData);\n\n        return new Spine({\n            skeletonData,\n        });\n    }\n}\n","/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Container, Graphics, Text } from 'pixi.js';\nimport { Spine } from './Spine';\nimport {\n    ClippingAttachment,\n    MeshAttachment,\n    PathAttachment,\n    RegionAttachment,\n    SkeletonBounds\n} from '@esotericsoftware/spine-core';\n\nimport type { AnimationStateListener } from '@esotericsoftware/spine-core';\n\n/**\n * Make a class that extends from this interface to create your own debug renderer.\n * @public\n */\nexport interface ISpineDebugRenderer\n{\n    /**\n     * This will be called every frame, after the spine has been updated.\n     */\n    renderDebug: (spine: Spine) => void;\n\n    /**\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\n     */\n    unregisterSpine: (spine: Spine) => void;\n\n    /**\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\n     */\n    registerSpine: (spine: Spine) => void;\n}\n\ntype DebugDisplayObjects = {\n    bones: Container;\n    skeletonXY: Graphics;\n    regionAttachmentsShape: Graphics;\n    meshTrianglesLine: Graphics;\n    meshHullLine: Graphics;\n    clippingPolygon: Graphics;\n    boundingBoxesRect: Graphics;\n    boundingBoxesCircle: Graphics;\n    boundingBoxesPolygon: Graphics;\n    pathsCurve: Graphics;\n    pathsLine: Graphics;\n    parentDebugContainer: Container;\n    eventText: Container;\n    eventCallback: AnimationStateListener;\n};\n\n/**\n * This is a debug renderer that uses PixiJS Graphics under the hood.\n * @public\n */\nexport class SpineDebugRenderer implements ISpineDebugRenderer\n{\n    private readonly registeredSpines: Map<Spine, DebugDisplayObjects> = new Map();\n\n    public drawMeshHull = true;\n    public drawMeshTriangles = true;\n    public drawBones = true;\n    public drawPaths = true;\n    public drawBoundingBoxes = true;\n    public drawClipping = true;\n    public drawRegionAttachments = true;\n    public drawEvents = true;\n\n    public lineWidth = 1;\n    public regionAttachmentsColor = 0x0078ff;\n    public meshHullColor = 0x0078ff;\n    public meshTrianglesColor = 0xffcc00;\n    public clippingPolygonColor = 0xff00ff;\n    public boundingBoxesRectColor = 0x00ff00;\n    public boundingBoxesPolygonColor = 0x00ff00;\n    public boundingBoxesCircleColor = 0x00ff00;\n    public pathsCurveColor = 0xff0000;\n    public pathsLineColor = 0xff00ff;\n    public skeletonXYColor = 0xff0000;\n    public bonesColor = 0x00eecc;\n    public eventFontSize = 24;\n    public eventFontColor = 0x0;\n\n    /**\n     * The debug is attached by force to each spine object.\n     * So we need to create it inside the spine when we get the first update\n     */\n    public registerSpine(spine: Spine): void\n    {\n        if (this.registeredSpines.has(spine))\n        {\n            console.warn('SpineDebugRenderer.registerSpine() - this spine is already registered!', spine);\n\n            return;\n        }\n        const debugDisplayObjects: DebugDisplayObjects = {\n            parentDebugContainer: new Container(),\n            bones: new Container(),\n            skeletonXY: new Graphics(),\n            regionAttachmentsShape: new Graphics(),\n            meshTrianglesLine: new Graphics(),\n            meshHullLine: new Graphics(),\n            clippingPolygon: new Graphics(),\n            boundingBoxesRect: new Graphics(),\n            boundingBoxesCircle: new Graphics(),\n            boundingBoxesPolygon: new Graphics(),\n            pathsCurve: new Graphics(),\n            pathsLine: new Graphics(),\n            eventText: new Container(),\n            eventCallback: {\n                event: (_, event) =>\n                {\n                    if (this.drawEvents)\n                    {\n                        const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\n                        const text = new Text({\n                            text: event.data.name,\n                            style: {\n                                fontSize: this.eventFontSize / scale,\n                                fill: this.eventFontColor,\n                                fontFamily: 'monospace'\n                            }\n                        });\n\n                        text.scale.x = Math.sign(spine.scale.x);\n                        text.anchor.set(0.5);\n                        debugDisplayObjects.eventText.addChild(text);\n                        setTimeout(() =>\n                        {\n                            if (!text.destroyed)\n                            {\n                                text.destroy();\n                            }\n                        }, 250);\n                    }\n                },\n            },\n        };\n\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.eventText);\n\n        (debugDisplayObjects.parentDebugContainer as any).zIndex = 9999999;\n\n        // Disable screen reader and mouse input on debug objects.\n        (debugDisplayObjects.parentDebugContainer as any).accessibleChildren = false;\n        (debugDisplayObjects.parentDebugContainer as any).eventMode = 'none';\n        (debugDisplayObjects.parentDebugContainer as any).interactiveChildren = false;\n\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\n\n        spine.state.addListener(debugDisplayObjects.eventCallback);\n\n        this.registeredSpines.set(spine, debugDisplayObjects);\n    }\n\n    public renderDebug(spine: Spine): void\n    {\n        if (!this.registeredSpines.has(spine))\n        {\n            // This should never happen. Spines are registered when you assign spine.debug\n            this.registerSpine(spine);\n        }\n\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        if (!debugDisplayObjects)\n        {\n            return;\n        }\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\n\n        debugDisplayObjects.skeletonXY.clear();\n        debugDisplayObjects.regionAttachmentsShape.clear();\n        debugDisplayObjects.meshTrianglesLine.clear();\n        debugDisplayObjects.meshHullLine.clear();\n        debugDisplayObjects.clippingPolygon.clear();\n        debugDisplayObjects.boundingBoxesRect.clear();\n        debugDisplayObjects.boundingBoxesCircle.clear();\n        debugDisplayObjects.boundingBoxesPolygon.clear();\n        debugDisplayObjects.pathsCurve.clear();\n        debugDisplayObjects.pathsLine.clear();\n\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--)\n        {\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, textureSource: true });\n        }\n\n        const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\n        const lineWidth = this.lineWidth / scale;\n\n        if (this.drawBones)\n        {\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n        }\n\n        if (this.drawPaths)\n        {\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawBoundingBoxes)\n        {\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawClipping)\n        {\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawMeshHull || this.drawMeshTriangles)\n        {\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawRegionAttachments)\n        {\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawEvents)\n        {\n            for (const child of debugDisplayObjects.eventText.children)\n            {\n                child.alpha -= 0.05;\n                child.y -= 2;\n            }\n        }\n    }\n\n    private drawBonesFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number, scale: number): void\n    {\n        const skeleton = spine.skeleton;\n        const skeletonX = skeleton.x;\n        const skeletonY = skeleton.y;\n        const bones = skeleton.bones;\n\n        debugDisplayObjects.skeletonXY.strokeStyle = { width: lineWidth, color: this.skeletonXYColor };\n\n        for (let i = 0, len = bones.length; i < len; i++)\n        {\n            const bone = bones[i];\n            const boneLen = bone.data.length;\n            const starX = skeletonX + bone.worldX;\n            const starY = skeletonY + bone.worldY;\n            const endX = skeletonX + (boneLen * bone.a) + bone.worldX;\n            const endY = skeletonY + (boneLen * bone.b) + bone.worldY;\n\n            if (bone.data.name === 'root' || bone.data.parent === null)\n            {\n                continue;\n            }\n\n            const w = Math.abs(starX - endX);\n            const h = Math.abs(starY - endY);\n            // a = w, // side length a\n            const a2 = Math.pow(w, 2); // square root of side length a\n            const b = h; // side length b\n            const b2 = Math.pow(h, 2); // square root of side length b\n            const c = Math.sqrt(a2 + b2); // side length c\n            const c2 = Math.pow(c, 2); // square root of side length c\n            const rad = Math.PI / 180;\n            // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\n            // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\n            const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\n\n            if (c === 0)\n            {\n                continue;\n            }\n\n            const gp = new Graphics();\n\n            debugDisplayObjects.bones.addChild(gp);\n\n            // draw bone\n            const refRation = c / 50 / scale;\n\n            gp.context\n                .poly([0, 0, 0 - refRation, c - (refRation * 3), 0, c - refRation, 0 + refRation, c - (refRation * 3)])\n                .fill(this.bonesColor);\n            gp.x = starX;\n            gp.y = starY;\n            gp.pivot.y = c;\n\n            // Calculate bone rotation angle\n            let rotation = 0;\n\n            if (starX < endX && starY < endY)\n            {\n                // bottom right\n                rotation = -B + (180 * rad);\n            }\n            else if (starX > endX && starY < endY)\n            {\n                // bottom left\n                rotation = 180 * (rad + B);\n            }\n            else if (starX > endX && starY > endY)\n            {\n                // top left\n                rotation = -B;\n            }\n            else if (starX < endX && starY > endY)\n            {\n                // bottom left\n                rotation = B;\n            }\n            else if (starY === endY && starX < endX)\n            {\n                // To the right\n                rotation = 90 * rad;\n            }\n            else if (starY === endY && starX > endX)\n            {\n                // go left\n                rotation = -90 * rad;\n            }\n            else if (starX === endX && starY < endY)\n            {\n                // down\n                rotation = 180 * rad;\n            }\n            else if (starX === endX && starY > endY)\n            {\n                // up\n                rotation = 0;\n            }\n            gp.rotation = rotation;\n\n            // Draw the starting rotation point of the bone\n            gp.circle(0, c, refRation * 1.2)\n                .fill({ color: 0x000000, alpha: 0.6 })\n                .stroke({ width: lineWidth, color: this.skeletonXYColor });\n        }\n\n        // Draw the skeleton starting point \"X\" form\n        const startDotSize = lineWidth * 3;\n\n        debugDisplayObjects.skeletonXY.context\n            .moveTo(skeletonX - startDotSize, skeletonY - startDotSize)\n            .lineTo(skeletonX + startDotSize, skeletonY + startDotSize)\n            .moveTo(skeletonX + startDotSize, skeletonY - startDotSize)\n            .lineTo(skeletonX - startDotSize, skeletonY + startDotSize)\n            .stroke();\n    }\n\n    private drawRegionAttachmentsFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof RegionAttachment))\n            {\n                continue;\n            }\n\n            const regionAttachment = attachment;\n\n            const vertices = new Float32Array(8);\n\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n\n            debugDisplayObjects.regionAttachmentsShape.poly(Array.from(vertices.slice(0, 8)));\n        }\n\n        debugDisplayObjects.regionAttachmentsShape.stroke({\n            color: this.regionAttachmentsColor,\n            width: lineWidth\n        });\n    }\n\n    private drawMeshHullAndMeshTriangles(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n\n            if (!slot.bone.active)\n            {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof MeshAttachment))\n            {\n                continue;\n            }\n\n            const meshAttachment = attachment;\n\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n            const triangles = meshAttachment.triangles;\n            let hullLength = meshAttachment.hullLength;\n\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n            // draw the skinned mesh (triangle)\n            if (this.drawMeshTriangles)\n            {\n                for (let i = 0, len = triangles.length; i < len; i += 3)\n                {\n                    const v1 = triangles[i] * 2;\n                    const v2 = triangles[i + 1] * 2;\n                    const v3 = triangles[i + 2] * 2;\n\n                    debugDisplayObjects.meshTrianglesLine.context\n                        .moveTo(vertices[v1], vertices[v1 + 1])\n                        .lineTo(vertices[v2], vertices[v2 + 1])\n                        .lineTo(vertices[v3], vertices[v3 + 1]);\n                }\n            }\n\n            // draw skin border\n            if (this.drawMeshHull && hullLength > 0)\n            {\n                hullLength = (hullLength >> 1) * 2;\n                let lastX = vertices[hullLength - 2];\n                let lastY = vertices[hullLength - 1];\n\n                for (let i = 0, len = hullLength; i < len; i += 2)\n                {\n                    const x = vertices[i];\n                    const y = vertices[i + 1];\n\n                    debugDisplayObjects.meshHullLine.context\n                        .moveTo(x, y)\n                        .lineTo(lastX, lastY);\n                    lastX = x;\n                    lastY = y;\n                }\n            }\n        }\n\n        debugDisplayObjects.meshHullLine.stroke({ width: lineWidth, color: this.meshHullColor });\n        debugDisplayObjects.meshTrianglesLine.stroke({ width: lineWidth, color: this.meshTrianglesColor });\n    }\n\n    drawClippingFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n\n            if (!slot.bone.active)\n            {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof ClippingAttachment))\n            {\n                continue;\n            }\n\n            const clippingAttachment = attachment;\n\n            const nn = clippingAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            debugDisplayObjects.clippingPolygon.poly(Array.from(world));\n        }\n\n        debugDisplayObjects.clippingPolygon.stroke({\n            width: lineWidth, color: this.clippingPolygonColor, alpha: 1\n        });\n    }\n\n    drawBoundingBoxesFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        // draw the total outline of the bounding box\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n\n        const bounds = new SkeletonBounds();\n\n        bounds.update(spine.skeleton, true);\n\n        debugDisplayObjects.boundingBoxesRect\n            .rect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight())\n            .stroke({ width: lineWidth, color: this.boundingBoxesRectColor });\n\n        const polygons = bounds.polygons;\n        const drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void =>\n        {\n            if (count < 3)\n            {\n                throw new Error('Polygon must contain at least 3 vertices');\n            }\n            const paths:number[] = [];\n            const dotSize = lineWidth * 2;\n\n            for (let i = 0, len = polygonVertices.length; i < len; i += 2)\n            {\n                const x1 = polygonVertices[i];\n                const y1 = polygonVertices[i + 1];\n\n                // draw the bounding box node\n                debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n                debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n                debugDisplayObjects.boundingBoxesCircle.fill(0);\n\n                paths.push(x1, y1);\n            }\n\n            // draw the bounding box area\n            debugDisplayObjects.boundingBoxesPolygon\n                .poly(paths)\n                .fill({\n                    color: this.boundingBoxesPolygonColor,\n                    alpha: 0.1\n                })\n                .stroke({\n                    width: lineWidth,\n                    color: this.boundingBoxesPolygonColor\n                });\n        };\n\n        for (let i = 0, len = polygons.length; i < len; i++)\n        {\n            const polygon = polygons[i];\n\n            drawPolygon(polygon, 0, polygon.length);\n        }\n    }\n\n    private drawPathsFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n\n            if (!slot.bone.active)\n            {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof PathAttachment))\n            {\n                continue;\n            }\n\n            const pathAttachment = attachment;\n            let nn = pathAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            let x1 = world[2];\n            let y1 = world[3];\n            let x2 = 0;\n            let y2 = 0;\n\n            if (pathAttachment.closed)\n            {\n                const cx1 = world[0];\n                const cy1 = world[1];\n                const cx2 = world[nn - 2];\n                const cy2 = world[nn - 1];\n\n                x2 = world[nn - 4];\n                y2 = world[nn - 3];\n\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n            }\n            nn -= 4;\n            for (let ii = 4; ii < nn; ii += 6)\n            {\n                const cx1 = world[ii];\n                const cy1 = world[ii + 1];\n                const cx2 = world[ii + 2];\n                const cy2 = world[ii + 3];\n\n                x2 = world[ii + 4];\n                y2 = world[ii + 5];\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n                x1 = x2;\n                y1 = y2;\n            }\n        }\n\n        debugDisplayObjects.pathsCurve.stroke({ width: lineWidth, color: this.pathsCurveColor });\n        debugDisplayObjects.pathsLine.stroke({ width: lineWidth, color: this.pathsLineColor });\n    }\n\n    public unregisterSpine(spine: Spine): void\n    {\n        if (!this.registeredSpines.has(spine))\n        {\n            console.warn('SpineDebugRenderer.unregisterSpine() - spine is not registered, can\\'t unregister!', spine);\n        }\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        if (!debugDisplayObjects)\n        {\n            return;\n        }\n\n        spine.state.removeListener(debugDisplayObjects.eventCallback);\n\n        debugDisplayObjects.parentDebugContainer.destroy({ textureSource: true, children: true, texture: true });\n        this.registeredSpines.delete(spine);\n    }\n}\n"],"names":["prevRequire","x","c","a","i","e","o","_SpineTexture","Texture","image","__publicField","PixiTexture","texture","minFilter","magFilter","style","uWrap","vWrap","filter","TextureFilter","wrap","TextureWrap","blend","BlendMode","SpineTexture","R","w","S","u","L","M","t","s","d","spineTextureAtlasLoader","ExtensionType","LoaderParserPriority","url","checkExtension","DOMAdapter","asset","options","isExtensionRight","isString","atlas","loader","metadata","basePath","path","retval","TextureAtlas","TextureSource","pixiTexture","textureLoadingPromises","page","pageName","providedPage","assetsToLoadIn","__spreadProps","__spreadValues","pixiPromise","extensions","isJson","resource","isBuffer","spineLoaderExtension","response","isJsonSpineModel","isBinarySpineModel","placeHolderBufferData","placeHolderIndexData","DarkTintBatchGeometry","Geometry","attributeBuffer","Buffer","BufferUsage","indexBuffer","stride","darkTintBit","darkTintBitGl","DarkTintShader","Shader","maxTextures","glProgram","compileHighShaderGlProgram","colorBitGl","generateTextureBatchBitGl","roundPixelsBitGl","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","roundPixelsBit","getBatchSamplersUniformGroup","defaultShader","_DarkTintBatcher","Batcher","element","float32View","uint32View","index","textureId","textureIdAndRound","wt","b","tx","ty","positions","uvs","argb","worldAlpha","darkColor","Color","offset","end","i2","y","bounds","w0","w1","h0","h1","DarkTintBatcher","BatchableSpineSlot","slotColor","parentColor","parentAlpha","abgr","mixedA","parentB","parentG","parentR","mixedR","mixedG","mixedB","renderable","data","blendMode","roundPixels","clippedData","clipper","SkeletonClipping","spineBlendModeMap","SpinePipe","renderer","spine","drawOrder","gpuSpine","n","slot","attachment","RegionAttachment","MeshAttachment","cacheData","batchableSpineSlot","instructionSet","_a","_b","_c","_d","batcher","containerAttachment","container","collectAllRenderables","vectorAux","Vector2","lightColor","Skeleton","Spine","ViewContainer","SkeletonData","skeletonData","AnimationState","AnimationStateData","slots","slotRef","value","Ticker","dt","_deltaFrame","deltaSeconds","bone","position","boneAux","aux","outPos","time","skeleton","Physics","currentDrawOrder","lastAttachments","spineAttachmentsDirty","skeletonColor","attachmentColor","ClippingAttachment","clippedVertices","clippedTriangles","verticesCount","indicesCount","sizeChange","vertices","indices","slotAttachment","DEG_TO_RAD","renderGroup","slotOrContainer","containerToRemove","Container","SkeletonBounds","skeletonBounds","point","scale","cacheKey","Cache","skeletonAsset","Assets","atlasAsset","attachmentLoader","AtlasAttachmentLoader","parser","SkeletonBinary","SkeletonJson","SpineDebugRenderer","debugDisplayObjects","Graphics","_","event","text","Text","len","lineWidth","child","skeletonX","skeletonY","bones","boneLen","starX","starY","endX","endY","h","a2","b2","c2","rad","B","gp","refRation","rotation","startDotSize","regionAttachment","meshAttachment","triangles","hullLength","v1","v2","v3","lastX","lastY","clippingAttachment","nn","world","polygons","drawPolygon","polygonVertices","_offset","count","paths","dotSize","x1","y1","polygon","PathAttachment","pathAttachment","x2","y2","cx1","cy1","cx2","cy2","ii"],"mappings":";;;;;;;;+lCAuCA,GAAI,OAAO,QAAW,aAAe,OAAO,KAC5C,CACI,MAAMA,EAAc,OAAO,QAG1B,OAAe,QAAWC,GAC3B,CACI,GAAID,EAAa,OAAOA,EAAYC,CAAC,EAChC,GAAIA,EAAE,WAAW,QAAQ,GAAKA,EAAE,WAAW,SAAS,EAAG,OAAO,OAAO,IAC9E,CACJ,CCpBA,IAAAC,GAAA,OAAA,eAAAD,GAAA,CAAAE,EAAAC,EAAAC,IAAAD,KAAAD,EAAAD,GAAAC,EAAAC,EAAA,CAAA,WAAA,GAAA,aAAA,GAAA,SAAA,GAAA,MAAAC,CAAA,CAAA,EAAAF,EAAAC,CAAA,EAAAC,EAAAC,GAAA,CAAAH,EAAAC,EAAAC,KAAAJ,GAAAE,EAAA,OAAAC,GAAA,SAAAA,EAAA,GAAAA,EAAAC,CAAA,EAAAA,GAKO,MAAME,GAAN,MAAMA,UAAqBC,EAClC,CAeY,YAAYC,EACpB,CAEI,MAAMA,EAAM,QAAQ,EALxBC,GAAA,KAAgB,SAAA,EAMZ,KAAK,QAAUC,GAAY,KAAKF,CAAK,CACzC,CAjBA,OAAc,KAAKG,EACnB,CACI,OAAIL,EAAa,WAAW,IAAIK,CAAO,EAE5BL,EAAa,WAAW,IAAIK,CAAO,EAGvC,IAAIL,EAAaK,CAAO,CACnC,CAWO,WAAWC,EAA0BC,EAC5C,CACI,MAAMC,EAAQ,KAAK,QAAQ,OAAO,MAElCA,EAAM,UAAYR,EAAa,oBAAoBM,CAAS,EAC5DE,EAAM,UAAYR,EAAa,oBAAoBO,CAAS,EAC5D,KAAK,QAAQ,OAAO,oBAAsBP,EAAa,aAAaM,CAAS,EAC7E,KAAK,QAAQ,OAAO,cACxB,CAAA,CAEO,SAASG,EAAoBC,EACpC,CACI,MAAMF,EAAQ,KAAK,QAAQ,OAAO,MAElCA,EAAM,aAAeR,EAAa,kBAAkBS,CAAK,EACzDD,EAAM,aAAeR,EAAa,kBAAkBU,CAAK,CAC7D,CAEO,SACP,CAEI,KAAK,QAAQ,QAAQ,CACzB,CAEA,OAAe,aAAaC,EAC5B,CACI,OAAQA,EAAAA,CAEJ,KAAKC,EAAc,QACnB,KAAKA,EAAc,OACf,MAAO,GAEX,KAAKA,EAAc,oBACnB,KAAKA,EAAc,qBACnB,KAAKA,EAAc,mBACnB,KAAKA,EAAc,oBACf,MAAO,GAEX,QACI,MAAM,IAAI,MAAM,2BAA2B,OAAOD,CAAM,CAAC,EAAE,CACnE,CACJ,CAEA,OAAe,oBAAoBA,EACnC,CACI,OAAQA,EAEJ,CAAA,KAAKC,EAAc,QACnB,KAAKA,EAAc,oBACnB,KAAKA,EAAc,qBACf,MAAO,UAEX,KAAKA,EAAc,OACnB,KAAKA,EAAc,mBACnB,KAAKA,EAAc,oBACf,MAAO,SAEX,QACI,MAAM,IAAI,MAAM,2BAA2B,OAAOD,CAAM,CAAC,EAAE,CACnE,CACJ,CAEA,OAAe,kBAAkBE,EACjC,CACI,OAAQA,EACR,CACI,KAAKC,EAAY,YACb,MAAO,gBAEX,KAAKA,EAAY,eACb,MAAO,gBAEX,KAAKA,EAAY,OACb,MAAO,SAEX,QACI,MAAM,IAAI,MAAM,yBAAyB,OAAOD,CAAI,CAAC,EAAE,CAC/D,CACJ,CAEA,OAAc,eAAeE,EAC7B,CACI,OAAQA,EAEJ,CAAA,KAAKC,EAAU,OACX,MAAO,SAEX,KAAKA,EAAU,SACX,MAAO,MAEX,KAAKA,EAAU,SACX,MAAO,WAEX,KAAKA,EAAU,OACX,MAAO,SAEX,QACI,MAAM,IAAI,MAAM,sBAAsB,OAAOD,CAAK,CAAC,EAAE,CAC7D,CACJ,CACJ,EAzHIZ,GAFSH,GAEe,aAA+C,IAAI,GAAA,MAFlEiB,EAANjB,GCLP,IAAAkB,GAAA,OAAA,eAAAC,GAAA,OAAA,iBAAAC,GAAA,OAAA,0BAAAC,GAAA,OAAA,sBAAAC,GAAA,OAAA,UAAA,eAAAC,GAAA,OAAA,UAAA,qBAAA7B,GAAA,CAAAI,EAAA0B,EAAAC,IAAAD,KAAA1B,EAAAoB,GAAApB,EAAA0B,EAAA,CAAA,WAAA,GAAA,aAAA,GAAA,SAAA,GAAA,MAAAC,CAAA,CAAA,EAAA3B,EAAA0B,CAAA,EAAAC,EAAA9B,GAAA,CAAAG,EAAA0B,IAAA,CAAA,QAAAC,KAAAD,IAAAA,EAAA,CAAA,GAAAF,GAAA,KAAAE,EAAAC,CAAA,GAAA/B,GAAAI,EAAA2B,EAAAD,EAAAC,CAAA,CAAA,EAAA,GAAAJ,GAAA,QAAAI,KAAAJ,GAAAG,CAAA,EAAAD,GAAA,KAAAC,EAAAC,CAAA,GAAA/B,GAAAI,EAAA2B,EAAAD,EAAAC,CAAA,CAAA,EAAA,OAAA3B,CAAA,EAAA4B,GAAA,CAAA5B,EAAA0B,IAAAL,GAAArB,EAAAsB,GAAAI,CAAA,CAAA,EAgBA,MAAMG,GAAwF,CAC1F,UAAWC,EAAc,MAEzB,OAAQ,CACJ,UAAW,CACP,KAAMA,EAAc,WACpB,SAAUC,GAAqB,OAC/B,KAAM,yBACV,EAEA,KAAKC,EACL,CACI,OAAOC,EAAeD,EAAK,QAAQ,CACvC,EAEA,MAAM,KAAKA,EACX,CAKI,OAFY,MAFK,MAAME,GAAW,IAAA,EAAM,MAAMF,CAAG,GAEtB,MAG/B,EAEA,UAAUG,EAAgBC,EAC1B,CACI,MAAMC,EAAmBJ,EAAeG,EAAQ,IAAe,QAAQ,EACjEE,EAAW,OAAOH,GAAU,SAElC,OAAO,QAAQ,QAAQE,GAAoBC,CAAQ,CACvD,EAEA,OAAOC,EACP,CACIA,EAAM,QACV,CAAA,EAEA,MAAM,MAAMJ,EAAiBC,EAAwBI,EACrD,CACI,MAAMC,EAAgCL,EAAQ,MAAQ,CAAC,EACvD,IAAIM,EAAWC,EAAK,QAAQP,EAAQ,GAAa,EAE7CM,GAAYA,EAAS,YAAY,GAAG,IAAMA,EAAS,OAAS,IAE5DA,GAAY,KAIhB,MAAME,EAAS,IAAIC,GAAaV,CAAK,EAGrC,GAAIM,EAAS,kBAAkBK,IAAiB,OAAOL,EAAS,QAAW,SAC3E,CACI,MAAMM,EAAcN,EAAS,OAE7BA,EAAS,OAAS,CAAC,EACnBA,EAAS,OAAOG,EAAO,MAAM,CAAC,EAAE,IAAI,EAAIG,CAC5C,CAGA,MAAMC,EAAwC,GAG9C,UAAWC,KAAQL,EAAO,MAC1B,CACI,MAAMM,EAAWD,EAAK,KAChBE,EAAeV,GAAA,MAAAA,EAAU,OAASA,EAAS,OAAOS,CAAQ,EAAI,OAEpE,GAAIC,aAAwBL,GAExBG,EAAK,WAAW9B,EAAa,KAAKgC,CAAY,CAAC,MAGnD,CAII,MAAMC,EAAiB,CACnB,IAHgBD,GAAA,KAAAA,EAAgBR,EAAK,UAAU,CAAC,GAAGD,EAAS,MAAMC,EAAK,GAAG,EAAGO,CAAQ,EAAE,KAAKP,EAAK,GAAG,CAAC,EAIrG,KAAMU,GAAAC,GAAA,CAAA,EACCb,EAAS,aAAA,EADV,CAEF,UAAWQ,EAAK,IAAM,sBAAwB,6BAClD,CACJ,CAAA,EAEMM,EAAcf,EAAO,KAAcY,CAAc,EAAE,KAAM7C,GAC/D,CACI0C,EAAK,WAAW9B,EAAa,KAAKZ,EAAQ,MAAM,CAAC,CACrD,CAAC,EAEDyC,EAAuB,KAAKO,CAAW,CAC3C,CACJ,CAEA,OAAM,MAAA,QAAQ,IAAIP,CAAsB,EAEjCJ,CACX,CACJ,CACJ,EAEAY,EAAW,IAAI3B,EAAuB,ECxGtC,SAAS4B,GAAOC,EAChB,CACI,OAAO,OAAO,UAAU,eAAe,KAAKA,EAAU,OAAO,CACjE,CAEA,SAASC,GAASD,EAClB,CACI,OAAOA,aAAoB,UAC/B,CAEA,MAAME,GAAgF,CAClF,UAAW9B,EAAc,MAEzB,OAAQ,CACJ,UAAW,CACP,KAAMA,EAAc,WACpB,SAAUC,GAAqB,OAC/B,KAAM,qBACV,EAEA,KAAKC,EACL,CACI,OAAOC,EAAeD,EAAK,OAAO,CACtC,EAEA,MAAM,KAAKA,EACX,CACI,MAAM6B,EAAW,MAAM3B,GAAW,MAAM,MAAMF,CAAG,EAIjD,OAFe,IAAI,WAAW,MAAM6B,EAAS,YAAY,CAAC,CAG9D,EACA,UAAU1B,EAAgBC,EAC1B,CACI,MAAM0B,EAAmB7B,EAAeG,EAAQ,IAAK,OAAO,GAAKqB,GAAOtB,CAAK,EACvE4B,EAAqB9B,EAAeG,EAAQ,IAAK,OAAO,GAAKuB,GAASxB,CAAK,EAEjF,OAAO,QAAQ,QAAQ2B,GAAoBC,CAAkB,CACjE,CACJ,CACJ,EAEAP,EAAW,IAAII,EAAoB,ECnFnC,MAAMI,GAAwB,IAAI,aAAa,CAAC,EAC1CC,GAAuB,IAAI,YAAY,CAAC,EAEjC,MAAAC,WAA8BC,EAC3C,CACI,aACA,CAGI,MAAMC,EAAkB,IAAIC,GAAO,CAC/B,KAAML,GACN,MAAO,yBACP,MAAOM,EAAY,OAASA,EAAY,SACxC,YAAa,EACjB,CAAC,EAEKC,EAAc,IAAIF,GAAO,CAC3B,KAAMJ,GACN,MAAO,qBACP,MAAOK,EAAY,MAAQA,EAAY,SACvC,YAAa,EACjB,CAAC,EAEKE,EAAS,EAAa,EAE5B,MAAM,CACF,WAAY,CACR,UAAW,CACP,OAAQJ,EACR,OAAQ,YACR,OAAAI,EACA,OAAQ,CACZ,EACA,IAAK,CACD,OAAQJ,EACR,OAAQ,YACR,OAAAI,EACA,OAAQ,EAAI,CAChB,EACA,OAAQ,CACJ,OAAQJ,EACR,OAAQ,WACR,OAAAI,EACA,OAAQ,EAAI,CAChB,EACA,WAAY,CACR,OAAQJ,EACR,OAAQ,WACR,OAAAI,EACA,OAAQ,EAAI,CAChB,EACA,mBAAoB,CAChB,OAAQJ,EACR,OAAQ,WACR,OAAAI,EACA,OAAQ,EAAI,CAChB,CACJ,EACA,YAAAD,CACJ,CAAC,CACL,CACJ,CC9DO,MAAME,GAAc,CACvB,KAAM,YACN,OAAQ,CACJ,OAAkB;AAAA;AAAA;AAAA,UAIlB,KAAgB;AAAA;AAAA,SAGpB,EACA,SAAU,CACN,OAAkB;AAAA;AAAA,UAGlB,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAQnB,CACJ,EAEaC,GAAgB,CACzB,KAAM,YACN,OAAQ,CACJ,OAAkB;AAAA;AAAA;AAAA,UAIlB,KAAgB;AAAA;AAAA,SAGpB,EACA,SAAU,CACN,OAAkB;AAAA;AAAA,UAGlB,IAAe;AAAA;AAAA;AAAA;AAAA,SAKnB,CACJ,QClCaC,WAAuBC,EACpC,CACI,YAAYC,EACZ,CACI,MAAMC,EAAYC,GAA2B,CACzC,KAAM,kBACN,KAAM,CACFC,GACAN,GACAO,GAA0BJ,CAAW,EACrCK,EACJ,CACJ,CAAC,EAEKC,EAAaC,GAA4B,CAC3C,KAAM,kBACN,KAAM,CACFC,GACAZ,GACAa,GAAwBT,CAAW,EACnCU,EACJ,CACJ,CAAC,EAED,MAAM,CACF,UAAAT,EACA,WAAAK,EACA,UAAW,CACP,cAAeK,GAA6BX,CAAW,CAC3D,CACJ,CAAC,CACL,CACJ,qKClCA,IAAIY,GAAwB,KAGrB,MAAMC,GAAN,MAAMA,WAAwBC,EACrC,CADO,kCAUHtF,EAAA,KAAO,WAAW,IAAI6D,EACtB7D,EAAAA,EAAA,KAAO,SAASoF,KAAkBA,GAAgB,IAAId,GAAe,KAAK,WAAW,EACrFtE,EAAAA,EAAA,KAAO,OAAOqF,GAAgB,UAAU,MAGxCrF,EAAA,KAAO,aAAa,CAAA,CAAA,CAEb,eACHuF,EACAC,EACAC,EACAC,EACAC,EAEJ,CACI,MAAMC,EAAqBD,GAAa,GAAOJ,EAAQ,YAAc,MAE/DM,EAAKN,EAAQ,UAEb9F,EAAIoG,EAAG,EACPC,EAAID,EAAG,EACPrG,EAAIqG,EAAG,EACPtE,EAAIsE,EAAG,EACPE,EAAKF,EAAG,GACRG,EAAKH,EAAG,GAER,CAAE,UAAAI,EAAW,IAAAC,CAAI,EAAIX,EAErBY,EAAOZ,EAAQ,MACfa,GAAeD,GAAQ,GAAM,KAAQ,IACrCE,EAAYC,GAAM,OAAO,SAASf,EAAQ,SAAS,EAAE,YAAYa,EAAY,EAAI,EAAE,gBAAgB,EAAG,EAAK,EAE3GG,EAAShB,EAAQ,gBACjBiB,EAAMD,EAAShB,EAAQ,cAE7B,QAAS7F,EAAI6G,EAAQ7G,EAAI8G,EAAK9G,IAC9B,CACI,MAAM+G,EAAK/G,EAAI,EAETH,EAAI0G,EAAUQ,CAAE,EAChBC,EAAIT,EAAWQ,EAAM,CAAC,EAE5BjB,EAAYE,GAAO,EAAKjG,EAAIF,EAAMC,EAAIkH,EAAKX,EAC3CP,EAAYE,GAAO,EAAKnE,EAAImF,EAAMZ,EAAIvG,EAAKyG,EAE3CR,EAAYE,GAAO,EAAIQ,EAAIO,CAAE,EAC7BjB,EAAYE,GAAO,EAAIQ,EAAKO,EAAM,CAAC,EAEnChB,EAAWC,GAAO,EAAIS,EACtBV,EAAWC,GAAO,EAAIW,EAEtBZ,EAAWC,GAAO,EAAIE,CAC1B,CACJ,CAEO,mBACHL,EACAC,EACAC,EACAC,EACAC,EAEJ,CACI,MAAMzF,EAAUqF,EAAQ,QAElBM,EAAKN,EAAQ,UAEb9F,EAAIoG,EAAG,EACPC,EAAID,EAAG,EACPrG,EAAIqG,EAAG,EACPtE,EAAIsE,EAAG,EACPE,EAAKF,EAAG,GACRG,EAAKH,EAAG,GAERc,EAASpB,EAAQ,OAEjBqB,EAAKD,EAAO,KACZE,EAAKF,EAAO,KACZG,EAAKH,EAAO,KACZI,EAAKJ,EAAO,KAEZT,EAAMhG,EAAQ,IAIdiG,EAAOZ,EAAQ,MACfc,EAAYd,EAAQ,UAEpBK,EAAqBD,GAAa,GAAOJ,EAAQ,YAAc,MAErEC,EAAYE,EAAQ,CAAC,EAAKjG,EAAIoH,EAAOrH,EAAIuH,EAAMhB,EAC/CP,EAAYE,EAAQ,CAAC,EAAKnE,EAAIwF,EAAOjB,EAAIe,EAAMb,EAE/CR,EAAYE,EAAQ,CAAC,EAAIQ,EAAI,GAC7BV,EAAYE,EAAQ,CAAC,EAAIQ,EAAI,GAE7BT,EAAWC,EAAQ,CAAC,EAAIS,EACxBV,EAAWC,EAAQ,CAAC,EAAIW,EACxBZ,EAAWC,EAAQ,CAAC,EAAIE,EAGxBJ,EAAYE,EAAQ,CAAC,EAAKjG,EAAImH,EAAOpH,EAAIuH,EAAMhB,EAC/CP,EAAYE,EAAQ,CAAC,EAAKnE,EAAIwF,EAAOjB,EAAIc,EAAMZ,EAE/CR,EAAYE,EAAQ,CAAC,EAAIQ,EAAI,GAC7BV,EAAYE,EAAQ,EAAE,EAAIQ,EAAI,GAE9BT,EAAWC,EAAQ,EAAE,EAAIS,EACzBV,EAAWC,EAAQ,EAAE,EAAIW,EACzBZ,EAAWC,EAAQ,EAAE,EAAIE,EAGzBJ,EAAYE,EAAQ,EAAE,EAAKjG,EAAImH,EAAOpH,EAAIsH,EAAMf,EAChDP,EAAYE,EAAQ,EAAE,EAAKnE,EAAIuF,EAAOhB,EAAIc,EAAMZ,EAEhDR,EAAYE,EAAQ,EAAE,EAAIQ,EAAI,GAC9BV,EAAYE,EAAQ,EAAE,EAAIQ,EAAI,GAE9BT,EAAWC,EAAQ,EAAE,EAAIS,EACzBV,EAAWC,EAAQ,EAAE,EAAIW,EACzBZ,EAAWC,EAAQ,EAAE,EAAIE,EAGzBJ,EAAYE,EAAQ,EAAE,EAAKjG,EAAIoH,EAAOrH,EAAIsH,EAAMf,EAChDP,EAAYE,EAAQ,EAAE,EAAKnE,EAAIuF,EAAOhB,EAAIe,EAAMb,EAEhDR,EAAYE,EAAQ,EAAE,EAAIQ,EAAI,GAC9BV,EAAYE,EAAQ,EAAE,EAAIQ,EAAI,GAE9BT,EAAWC,EAAQ,EAAE,EAAIS,EACzBV,EAAWC,EAAQ,EAAE,EAAIW,EACzBZ,EAAWC,EAAQ,EAAE,EAAIE,CAC7B,CACJ,EA5II5F,EAHSqF,GAGK,YAAY,CACtB,KAAM,CACF5D,EAAc,OAClB,EACA,KAAM,UACV,CARG,EAAA,IAAMuF,GAAN3B,GAiJPlC,EAAW,IAAI6D,EAAe,sKC/HjB,MAAAC,EACb,CADO,aAAA,CAEHjH,EAAA,KAAA,cAAc,CACdA,EAAAA,EAAA,KAAkB,kBAAA,CAAA,EAElBA,EAAA,KAAA,WAAA,EACAA,EAAA,KAAA,eAAA,EAEAA,EAAA,KAAc,cAAA,UAAA,EAEdA,EAAA,KAAS,aAAa,EAAA,EAEtBA,EAAA,KAAA,YAAA,EAEAA,EAAA,KAAA,WAAA,EACAA,EAAA,KAAA,SAAA,EACAA,EAAA,KAAA,KAAA,EAEAA,EAAA,KACAA,aAAAA,EAAAA,EAAA,KACAA,MAAAA,EAAAA,EAAA,KAEAA,WAAAA,EAAAA,EAAA,KAEAA,UAAAA,EAAAA,EAAA,KAEAA,SAAAA,EAAAA,EAAA,KAIAA,WAAAA,EAAAA,EAAA,KACAA,YAAAA,EAAAA,EAAA,KACAA,iBAAAA,EAAAA,EAAA,KACAA,aAAAA,EAAAA,EAAA,KACAA,UAAAA,EAAAA,EAAA,KAEA,QAAA,CAAA,CAAA,IAAI,OACJ,CACI,MAAMkH,EAAY,KAAK,KAAK,MAEtBC,EAAqB,KAAK,WAAW,WACrCC,EAAqB,KAAK,WAAW,WAC3C,IAAIC,EAEJ,MAAMC,EAAUJ,EAAU,EAAIE,EAAe,IAE7C,GAAID,IAAgB,SACpB,CACI,MAAMI,EAAWJ,GAAe,GAAM,IAChCK,EAAWL,GAAe,EAAK,IAC/BM,EAAUN,EAAc,IAExBO,EAAUR,EAAU,EAAIO,EACxBE,EAAUT,EAAU,EAAIM,EACxBI,EAAUV,EAAU,EAAIK,EAE9BF,EAASC,GAAW,GAAOM,GAAU,GAAOD,GAAU,EAAKD,CAC/D,MAGIL,EAASC,GAAW,GAAQJ,EAAU,EAAI,KAAQ,GAAQA,EAAU,EAAI,KAAQ,EAAMA,EAAU,EAAI,IAGxG,OAAOG,CACX,CAEA,IAAI,WACJ,CACI,MAAMhB,EAAY,KAAK,KAAK,UAE5B,OAASA,EAAU,EAAI,KAAQ,GAAQA,EAAU,EAAI,KAAQ,EAAMA,EAAU,EAAI,GACrF,CAEA,IAAI,gBAAiB,CAAE,OAAO,KAAK,WAAW,cAAgB,CAE9D,QACIwB,EACAC,EACAC,EACAC,EACJ,CAKI,GAJA,KAAK,WAAaH,EAClB,KAAK,UAAYA,EAAW,eAC5B,KAAK,KAAOC,EAERA,EAAK,QACT,CACI,MAAMG,EAAcH,EAAK,YAEzB,KAAK,UAAYG,EAAY,aAC7B,KAAK,cAAgBA,EAAY,YACjC,KAAK,UAAYA,EAAY,SAC7B,KAAK,QAAUA,EAAY,QAC3B,KAAK,IAAMA,EAAY,GAC3B,MAGI,KAAK,UAAYH,EAAK,QAAQ,OAC9B,KAAK,cAAgBA,EAAK,SAAS,OAAS,EAC5C,KAAK,UAAYA,EAAK,SACtB,KAAK,QAAUA,EAAK,QACpB,KAAK,IAAMA,EAAK,IAGpB,KAAK,QAAUA,EAAK,QACpB,KAAK,YAAcE,EAEnB,KAAK,UAAYD,EAEjB,KAAK,YAAcD,EAAK,SAAW,WAAa,SACpD,CACJ,sKCxGA,MAAMI,GAAU,IAAIC,GAEdC,GAAoB,CACtB,EAAG,SACH,EAAG,MACH,EAAG,WACH,EAAG,QACP,QAGaC,EACb,CAeI,YAAYC,EACZ,CALAtI,GAAA,KAEAA,UAAAA,EAAAA,GAAA,KAAQ,eAAmC,CAAA,GAIvC,KAAK,SAAWsI,CACpB,CAEA,mBAAmBC,EACnB,CAII,GAHAA,EAAM,cAGFA,EAAM,sBAEN,MAAO,GAGN,GAAIA,EAAM,mBACf,CAEI,MAAMC,EAAYD,EAAM,SAAS,UAC3BE,EAAW,KAAK,aAAaF,EAAM,GAAG,EAE5C,QAAS7I,EAAI,EAAGgJ,EAAIF,EAAU,OAAQ9I,EAAIgJ,EAAGhJ,IAC7C,CACI,MAAMiJ,EAAOH,EAAU9I,CAAC,EAClBkJ,EAAaD,EAAK,cAAA,EAExB,GAAIC,aAAsBC,GAAoBD,aAAsBE,EACpE,CACI,MAAMC,EAAYR,EAAM,eAAeI,EAAMC,CAAU,EACjDI,EAAqBP,EAAS,YAAYM,EAAU,EAAE,EAEtD7I,EAAU6I,EAAU,QAE1B,GAAI7I,IAAY8I,EAAmB,SAE3B,CAACA,EAAmB,SAAS,sBAAsBA,EAAoB9I,CAAO,EAE9E,MAAO,EAGnB,CACJ,CACJ,CAEA,MAAO,EACX,CAEA,cAAcqI,EAAcU,EAC5B,CAlHJ,IAAAC,EAAAC,EAAAC,EAAAC,EAmHQ,MAAMZ,GAAWS,EAAA,KAAK,cAALC,EAAkBZ,EAAM,OAAxBW,EAAAC,CAAAA,EAAiC,CAAE,YAAa,EAAG,GAE9DG,EAAU,KAAK,SAAS,YAAY,MAEpCd,EAAYD,EAAM,SAAS,UAE3BP,EAAe,KAAK,SAAS,aAAeO,EAAM,aAExDA,EAAM,YAEN,EAAA,QAAS7I,EAAI,EAAGgJ,EAAIF,EAAU,OAAQ9I,EAAIgJ,EAAGhJ,IAC7C,CACI,MAAMiJ,EAAOH,EAAU9I,CAAC,EAClBkJ,EAAaD,EAAK,gBAClBZ,EAAYK,GAAkBO,EAAK,KAAK,SAAS,EAEvD,GAAIC,aAAsBC,GAAoBD,aAAsBE,EACpE,CACI,MAAMC,EAAYR,EAAM,eAAeI,EAAMC,CAAU,EACjDI,GAAqBI,EAAAX,EAAS,aAATY,EAAqBN,EAAU,MAA/BK,EAAAC,CAAAA,EAAuC,IAAIpC,IAEtE+B,EAAmB,QACfT,EACAQ,EACAhB,EACAC,CACJ,EAEKe,EAAU,YAEXO,EAAQ,WAAWN,EAAoBC,CAAc,CAE7D,CAEA,MAAMM,EAAsBhB,EAAM,aAAaI,EAAK,KAAK,IAAI,EAE7D,GAAIY,EACJ,CACI,MAAMC,EAAYD,EAAoB,UAEtCC,EAAU,eAAiB,GAC3BC,GAAsBD,EAAWP,EAAgB,KAAK,QAAQ,EAC9DO,EAAU,eAAiB,EAC/B,CACJ,CAEAtB,GAAQ,QAAQ,CACpB,CAEA,iBAAiBK,EACjB,CArKJ,IAAAW,EAuKQ,MAAMT,EAAW,KAAK,aAAaF,EAAM,GAAG,EAE5CA,EAAM,YAAY,EAElB,MAAMC,EAAYD,EAAM,SAAS,UAEjC,QAAS7I,EAAI,EAAGgJ,EAAIF,EAAU,OAAQ9I,EAAIgJ,EAAGhJ,IAC7C,CACI,MAAMiJ,EAAOH,EAAU9I,CAAC,EAClBkJ,EAAaD,EAAK,cAAc,EAEtC,IAAIC,aAAsBC,GAAoBD,aAAsBE,IAI5D,CAFcP,EAAM,eAAeI,EAAMC,CAAU,EAExC,WACf,CACI,MAAMI,EAAqBP,EAAS,YAAYF,EAAM,eAAeI,EAAMC,CAAU,EAAE,EAAE,GAEzFM,EAAAF,EAAmB,WAAnB,MAAAE,EAA6B,cAAcF,CAAAA,CAC/C,CAER,CACJ,CAEA,kBAAkBT,EAClB,CAEI,KAAK,aAAaA,EAAM,GAAG,EAAI,IACnC,CAEA,SACA,CACI,KAAK,aAAe,KACpB,KAAK,SAAW,IACpB,CACJ,CAtJIvI,GAHSqI,GAGF,YAAY,CACf,KAAM,CACF5G,EAAc,WACdA,EAAc,YACdA,EAAc,WAClB,EACA,KAAM,OACV,CAAA,EAiJJ0B,EAAW,IAAIkF,EAAS,sKCrIxB,MAAMqB,EAAY,IAAIC,GAChBC,GAAa,IAAItD,EACjBD,GAAY,IAAIC,EAEtBuD,GAAS,MAAQ,GAEjB,MAAM3B,EAAU,IAAIC,GAuCP,MAAA2B,UAAcC,EAC3B,CAgFI,YAAYhI,EACZ,CAvMJ,IAAAmH,EAwMYnH,aAAmBiI,KAEnBjI,EAAU,CACN,aAAcA,CAClB,GAGJ,MAAM,EAvFV/B,EAAA,KAAO,UAAU,EACjBA,EAAAA,EAAA,KAAO,UAAU,GACjBA,EAAA,KAAyB,eAAe,OACxCA,EAAAA,EAAA,KAAO,kBAAkB,EAAA,EAEzBA,EAAA,KAAO,8BAAuD,IAAM,CAAA,CACpEA,EAAAA,EAAA,KAAO,6BAAsD,IAAM,EAGnEA,EAAAA,EAAA,KAAO,UAAA,EACPA,EAAA,KAAO,SACPA,EAAA,KAAO,kBACPA,EAAA,KAAQ,UAERA,EAAA,KAAS,eAAiE,OAAO,OAAO,IAAI,GAe5FA,EAAA,KAAO,wBAAwB,EAC/BA,EAAAA,EAAA,KAAO,qBAAqB,EAAA,EAE5BA,EAAA,KAAQ,kBAERA,EAAAA,EAAA,KAAQ,gBAAgB,EAAA,EACxBA,EAAA,KAAQ,sBAA6D,CAoBrEA,CAAAA,EAAAA,EAAA,KAAQ,mBAAmB,EAC3BA,EAAAA,EAAA,KAAQ,cAAc,EAAA,EAiClB,MAAMiK,EAAelI,aAAmBiI,GAAejI,EAAUA,EAAQ,aAEzE,KAAK,SAAW,IAAI8H,GAASI,CAAY,EACzC,KAAK,MAAQ,IAAIC,GAAe,IAAIC,GAAmBF,CAAY,CAAC,EACpE,KAAK,YAAaf,EAAAnH,GAAA,YAAAA,EAAS,aAAT,KAAAmH,EAAuB,GAEzC,MAAMkB,EAAQ,KAAK,SAAS,MAE5B,QAAS1K,EAAI,EAAGA,EAAI0K,EAAM,OAAQ1K,IAE9B,KAAK,oBAAoBA,CAAC,EAAI,OAAO,OAAO,IAAI,EAGpD,KAAK,aAAa,CAAC,CACvB,CAvFQ,eAAe2K,EACvB,CACI,IAAI1B,EAMJ,GAJI,OAAO0B,GAAY,SAAU1B,EAAO,KAAK,SAAS,MAAM0B,CAAO,EAC1D,OAAOA,GAAY,SAAU1B,EAAO,KAAK,SAAS,SAAS0B,CAAO,EACtE1B,EAAO0B,EAER,CAAC1B,EAAM,MAAM,IAAI,MAAM,gDAAgD0B,CAAO,EAAE,EAEpF,OAAO1B,CACX,CAUA,IAAW,OACX,CACI,OAAO,KAAK,MAChB,CAEA,IAAW,MAAM2B,EACjB,CACQ,KAAK,QAEL,KAAK,OAAO,gBAAgB,IAAI,EAEhCA,GAEAA,EAAM,cAAc,IAAI,EAE5B,KAAK,OAASA,CAClB,CAKA,IAAW,YACX,CACI,OAAO,KAAK,WAChB,CAEA,IAAW,WAAWA,EACtB,CACQA,GAEAC,EAAO,OAAO,IAAI,KAAK,eAAgB,IAAI,EAC3C,KAAK,iBAAmB,IAIxBA,EAAO,OAAO,OAAO,KAAK,eAAgB,IAAI,EAGlD,KAAK,YAAcD,CACvB,CA6BO,OAAOE,EACd,CACQ,KAAK,YAAc,CAAC,KAAK,mBAEzB,QAAQ,KAEJ,iHACJ,EACA,KAAK,iBAAmB,IAG5B,KAAK,eAAe,EAAGA,CAAE,CAC7B,CAEU,eAAeC,EAAkBC,EAC3C,CAGI,KAAK,aAAaA,GAAA,KAAAA,EAAgBH,EAAO,OAAO,QAAU,GAAI,CAClE,CAEA,IAAI,QACJ,CACI,OAAI,KAAK,cAEL,KAAK,eAGF,KAAK,OAChB,CAEO,gBAAgBI,EAAqBC,EAC5C,CACI,MAAMC,EAAUF,EAOhB,GALI,OAAOA,GAAS,WAEhBA,EAAO,KAAK,SAAS,SAASA,CAAI,GAGlC,CAACA,EAAM,MAAM,MAAM,gCAAgC,OAAOE,CAAO,CAAC,YAAY,EAGlF,GAFAnB,EAAU,IAAIkB,EAAS,EAAGA,EAAS,CAAC,EAEhCD,EAAK,OACT,CACI,MAAMG,EAAMH,EAAK,OAAO,aAAajB,CAAS,EAE9CiB,EAAK,EAAIG,EAAI,EACbH,EAAK,EAAI,CAACG,EAAI,CAClB,MAGIH,EAAK,EAAIjB,EAAU,EACnBiB,EAAK,EAAIjB,EAAU,CAE3B,CAEO,gBAAgBiB,EAAqBI,EAC5C,CACI,MAAMF,EAAUF,EAOhB,OALI,OAAOA,GAAS,WAEhBA,EAAO,KAAK,SAAS,SAASA,CAAI,GAGjCA,GAOAI,IAEDA,EAAS,CAAE,EAAG,EAAG,EAAG,CAAE,GAG1BA,EAAO,EAAIJ,EAAK,OAChBI,EAAO,EAAIJ,EAAK,OAETI,IAbH,QAAQ,MAAM,gCAAgC,OAAOF,CAAO,CAAC,YAAY,EAElEE,EAYf,CASA,aAAaC,EACb,CACI,KAAK,MAAM,OAAOA,CAAI,EACtB,KAAK,SAAS,OAAOA,CAAI,EAEzB,KAAK,cAAgB,GAErB,KAAK,aAAe,GAEpB,KAAK,aAAa,CACtB,CAWA,aACA,CACI,GAAI,CAAC,KAAK,cAAe,OACzB,KAAK,cAAgB,GAErB,KAAM,CAAE,SAAAC,CAAS,EAAI,KAErB,KAAK,MAAM,MAAMA,CAAQ,EAEzB,KAAK,4BAA4B,IAAI,EACrCA,EAAS,qBAAqBC,GAAQ,MAAM,EAC5C,KAAK,2BAA2B,IAAI,EAEpC,KAAK,sBAEL,KAAK,qBAAqB,EAE1B,KAAK,kBACT,CAAA,CAEQ,qBACR,CACI,MAAMC,EAAmB,KAAK,SAAS,UAEjCC,EAAmB,KAAK,mBAAL,KAAK,iBAAqB,CAEnD,GAAA,IAAI1F,EAAQ,EAER2F,EAAwB,GAE5B,QAAS3L,EAAI,EAAGA,EAAIyL,EAAiB,OAAQzL,IAC7C,CAEI,MAAMkJ,EADOuC,EAAiBzL,CAAC,EACP,gBAEpBkJ,IAEIA,IAAewC,EAAgB1F,CAAK,IAEpC2F,EAAwB,GACxBD,EAAgB1F,CAAK,EAAIkD,GAG7BlD,IAER,CAEIA,IAAU0F,EAAgB,SAE1BC,EAAwB,GACxBD,EAAgB,OAAS1F,GAG7B,KAAK,sBAAwB2F,CACjC,CAEQ,sBACR,CA1YJ,IAAAnC,EA2YQ,MAAMiC,EAAmB,KAAK,SAAS,UAEvC,QAASzL,EAAI,EAAGA,EAAIyL,EAAiB,OAAQzL,IAC7C,CACI,MAAMiJ,EAAOwC,EAAiBzL,CAAC,EAEzBkJ,EAAaD,EAAK,gBAExB,GAAIC,GAEA,GAAIA,aAAsBE,GAAkBF,aAAsBC,EAClE,CACI,MAAME,EAAY,KAAK,eAAeJ,EAAMC,CAAU,EAElDA,aAAsBC,EAEtBD,EAAW,qBAAqBD,EAAMI,EAAU,SAAU,EAAG,CAAC,EAI9DH,EAAW,qBACPD,EACA,EACAC,EAAW,oBACXG,EAAU,SACV,EACA,CACJ,EAGJA,EAAU,IAAMH,EAAW,IAG3B,MAAM0C,EADW3C,EAAK,KAAK,SACI,MACzBzB,EAAYyB,EAAK,MAEjB4C,EAAkB3C,EAAW,MAEnCG,EAAU,MAAM,IACZuC,EAAc,EAAIpE,EAAU,EAAIqE,EAAgB,EAChDD,EAAc,EAAIpE,EAAU,EAAIqE,EAAgB,EAChDD,EAAc,EAAIpE,EAAU,EAAIqE,EAAgB,EAChDD,EAAc,EAAIpE,EAAU,EAAIqE,EAAgB,CACpD,EAEAxC,EAAU,SAAW,CAAC,CAACJ,EAAK,UAExBA,EAAK,WAELI,EAAU,UAAU,aAAaJ,EAAK,SAAS,EAGnDI,EAAU,WAAaA,EAAU,QAAU,GAE3C,MAAM7I,IAAUgJ,EAAAN,EAAW,SAAX,KAAA,OAAAM,EAAmB,QAAQ,UAAWpJ,GAAQ,MAE1DiJ,EAAU,UAAY7I,IAEtB6I,EAAU,QAAU7I,EACpB,KAAK,mBAAqB,IAG1BgI,EAAQ,WAER,GAAA,KAAK,mBAAmBa,CAAS,CAEzC,SACSH,aAAsB4C,GAC/B,CACItD,EAAQ,UAAUS,EAAMC,CAAU,EAClC,QACJ,EAEJV,EAAQ,gBAAgBS,CAAI,CAChC,CACAT,EAAQ,SACZ,CAEQ,mBAAmBa,EAC3B,CACIA,EAAU,QAAU,GAEpBb,EAAQ,cACJa,EAAU,SACVA,EAAU,SAAS,OACnBA,EAAU,QACVA,EAAU,QAAQ,OAClBA,EAAU,IACVa,GACAvD,GACA,EACJ,EAEA,KAAM,CAAE,gBAAAoF,EAAiB,iBAAAC,CAAiB,EAAIxD,EAExCyD,EAAgBF,EAAgB,OAAS,EACzCG,EAAeF,EAAiB,OAEjC3C,EAAU,cAEXA,EAAU,YAAc,CACpB,SAAU,IAAI,aAAa4C,EAAgB,CAAC,EAC5C,IAAK,IAAI,aAAaA,EAAgB,CAAC,EACvC,YAAaA,EACb,QAAS,IAAI,YAAYC,CAAY,EACrC,aAAAA,CACJ,EAEA,KAAK,sBAAwB,IAGjC,MAAM3D,EAAcc,EAAU,YAExB8C,EAAa5D,EAAY,cAAgB0D,GAAiBC,IAAiB3D,EAAY,aAE7Fc,EAAU,WAAa4C,IAAkB,EAErCE,IAEA,KAAK,sBAAwB,GAEzB5D,EAAY,YAAc0D,IAG1B1D,EAAY,SAAW,IAAI,aAAa0D,EAAgB,CAAC,EACzD1D,EAAY,IAAM,IAAI,aAAa0D,EAAgB,CAAC,GAGpD1D,EAAY,QAAQ,OAAS2D,IAE7B3D,EAAY,QAAU,IAAI,YAAY2D,CAAY,IAI1D,KAAM,CAAE,SAAAE,EAAU,IAAA5F,EAAK,QAAA6F,CAAQ,EAAI9D,EAEnC,QAASvI,EAAI,EAAGA,EAAIiM,EAAejM,IAE/BoM,EAASpM,EAAI,CAAC,EAAI+L,EAAgB/L,EAAI,CAAC,EACvCoM,EAAUpM,EAAI,EAAK,CAAC,EAAI+L,EAAiB/L,EAAI,EAAK,CAAC,EAEnDwG,EAAIxG,EAAI,CAAC,EAAI+L,EAAiB/L,EAAI,EAAK,CAAC,EACxCwG,EAAKxG,EAAI,EAAK,CAAC,EAAI+L,EAAiB/L,EAAI,EAAK,CAAC,EAGlDuI,EAAY,YAAc0D,EAE1B,QAASjM,EAAI,EAAGA,EAAIqM,EAAQ,OAAQrM,IAEhCqM,EAAQrM,CAAC,EAAIgM,EAAiBhM,CAAC,EAGnCuI,EAAY,aAAe2D,CAC/B,CAMQ,mBACR,CACI,UAAWlM,KAAK,KAAK,aACrB,CACI,MAAMsM,EAAiB,KAAK,aAAatM,CAAC,EAErCsM,GAEL,KAAK,iBAAiBA,CAAc,CACxC,CACJ,CAEQ,iBAAiBA,EACzB,CACI,KAAM,CAAE,KAAArD,EAAM,UAAAa,CAAU,EAAIwC,EAI5B,GAFAxC,EAAU,QAAU,KAAK,SAAS,UAAU,SAASb,CAAI,EAErDa,EAAU,QACd,CACI,MAAMmB,EAAOhC,EAAK,KAElBa,EAAU,SAAS,IAAImB,EAAK,OAAQA,EAAK,MAAM,EAE/CnB,EAAU,MAAM,EAAImB,EAAK,eAAA,EACzBnB,EAAU,MAAM,EAAImB,EAAK,iBAEzBnB,EAAU,SAAWmB,EAAK,kBAAsBsB,EAAAA,EACpD,CACJ,CAGA,eAAetD,EAAYC,EAC3B,CACI,OAAO,KAAK,oBAAoBD,EAAK,KAAK,KAAK,EAAEC,EAAW,IAAI,GAAK,KAAK,eAAeD,EAAMC,CAAU,CAC7G,CAEQ,eAAeD,EAAYC,EACnC,CAhlBJ,IAAAM,EAAAC,EAilBQ,IAAI2C,EAEJ,OAAIlD,aAAsBC,GAEtBiD,EAAW,IAAI,aAAa,CAAC,EAE7B,KAAK,oBAAoBnD,EAAK,KAAK,KAAK,EAAEC,EAAW,IAAI,EAAI,CACzD,GAAI,GAAGD,EAAK,KAAK,KAAK,IAAIC,EAAW,IAAI,GACzC,SAAAkD,EACA,QAAS,GACT,QAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAC1B,IAAKlD,EAAW,IAChB,MAAO,IAAItC,EAAM,EAAG,EAAG,EAAG,CAAC,EAC3B,UAAW,IAAIA,EAAM,EAAG,EAAG,EAAG,CAAC,EAC/B,SAAU,GACV,WAAY,GACZ,SAAS4C,EAAAN,EAAW,SAAX,YAAAM,EAAmB,QAAQ,OACxC,IAIA4C,EAAW,IAAI,aAAalD,EAAW,mBAAmB,EAE1D,KAAK,oBAAoBD,EAAK,KAAK,KAAK,EAAEC,EAAW,IAAI,EAAI,CACzD,GAAI,GAAGD,EAAK,KAAK,KAAK,IAAIC,EAAW,IAAI,GACzC,SAAAkD,EACA,QAAS,GACT,QAASlD,EAAW,UACpB,IAAKA,EAAW,IAChB,MAAO,IAAItC,EAAM,EAAG,EAAG,EAAG,CAAC,EAC3B,UAAW,IAAIA,EAAM,EAAG,EAAG,EAAG,CAAC,EAC/B,SAAU,GACV,WAAY,GACZ,SAAS6C,EAAAP,EAAW,SAAX,KAAA,OAAAO,EAAmB,QAAQ,OACxC,GAGG,KAAK,oBAAoBR,EAAK,KAAK,KAAK,EAAEC,EAAW,IAAI,CACpE,CAEU,cACV,CA1nBJ,IAAAM,EAgoBQ,GAJA,KAAK,cAAgB,KAErB,KAAK,aAAe,GAEhB,KAAK,cAAe,OACxB,KAAK,cAAgB,GAErB,MAAMgD,EAAc,KAAK,aAAe,KAAK,kBAEzCA,GAEAA,EAAY,kBAAkB,IAAI,GAGtChD,EAAA,KAAK,QAAL,MAAAA,EAAY,YAAY,IAAA,CAC5B,CASO,cAAcP,EAA8Ba,EACnD,CArpBJ,IAAAN,EAspBQP,EAAO,KAAK,eAAeA,CAAI,EAG/B,UAAWjJ,KAAK,KAAK,eAEbwJ,EAAA,KAAK,aAAaxJ,CAAC,IAAnB,KAAA,OAAAwJ,EAAsB,aAAcM,GAEpC,KAAK,iBAAiB,KAAK,aAAa9J,CAAC,EAAE,IAAI,EAIvD,KAAK,iBAAiBiJ,CAAI,EAE1Ba,EAAU,eAAiB,GAG3B,KAAK,SAASA,CAAS,EAEvB,KAAK,aAAab,EAAK,KAAK,IAAI,EAAI,CAChC,UAAAa,EACA,KAAAb,CACJ,EAEA,KAAK,iBAAiB,KAAK,aAAaA,EAAK,KAAK,IAAI,CAAC,CAC3D,CAQO,iBAAiBwD,EACxB,CAvrBJ,IAAAjD,EAAAC,EAwrBQ,IAAIiD,EAEJ,GAAID,aAA2BE,GAE3B,UAAW3M,KAAK,KAAK,aAEjB,KAAIwJ,EAAA,KAAK,aAAaxJ,CAAC,IAAnB,KAAAwJ,OAAAA,EAAsB,aAAciD,EACxC,CACI,KAAK,aAAazM,CAAC,EAAI,KAEvB0M,EAAoBD,EACpB,KACJ,MAIR,CACI,MAAMxD,EAAO,KAAK,eAAewD,CAAe,EAEhDC,GAAoBjD,EAAA,KAAK,aAAaR,EAAK,KAAK,IAAI,IAAhC,KAAAQ,OAAAA,EAAmC,UACvD,KAAK,aAAaR,EAAK,KAAK,IAAI,EAAI,IACxC,CAEIyD,IAEA,KAAK,YAAYA,CAAiB,EAElCA,EAAkB,eAAiB,GAE3C,CAQO,cAAczD,EACrB,CACI,OAAAA,EAAO,KAAK,eAAeA,CAAI,EAExB,KAAK,aAAaA,EAAK,KAAK,IAAI,EAAE,SAC7C,CAEQ,cACR,CACI,KAAK,aAAe,GAEpB,KAAK,iBAAL,KAAK,eAAmB,IAAI2D,IAE5B,MAAMC,EAAiB,KAAK,eAI5B,GAFAA,EAAe,OAAO,KAAK,SAAU,EAAI,EAErCA,EAAe,OAAS,IAC5B,CACI,KAAK,YAEL,EAAA,MAAM/D,EAAY,KAAK,SAAS,UAC1B7B,EAAS,KAAK,QAEpBA,EAAO,QAEP,QAASjH,EAAI,EAAGA,EAAI8I,EAAU,OAAQ9I,IACtC,CACI,MAAMiJ,EAAOH,EAAU9I,CAAC,EAElBkJ,EAAaD,EAAK,cAAA,EAExB,GAAIC,IAAeA,aAAsBC,GAAoBD,aAAsBE,GACnF,CACI,MAAMC,EAAY,KAAK,eAAeJ,EAAMC,CAAU,EAEtDjC,EAAO,cAAcoC,EAAU,SAAU,EAAGA,EAAU,SAAS,MAAM,CACzE,CACJ,CACJ,MAGI,KAAK,QAAQ,KAAOwD,EAAe,KACnC,KAAK,QAAQ,KAAOA,EAAe,KACnC,KAAK,QAAQ,KAAOA,EAAe,KACnC,KAAK,QAAQ,KAAOA,EAAe,IAE3C,CAGA,UAAU5F,EACV,CACIA,EAAO,UAAU,KAAK,MAAM,CAChC,CASgB,QAAQ5E,EAA0B,GAClD,CACI,MAAM,QAAQA,CAAO,EAErBwI,EAAO,OAAO,OAAO,KAAK,eAAgB,IAAI,EAC9C,KAAK,MAAM,eAAe,EAC1B,KAAK,MAAQ,OACb,KAAK,SAAW,KAChB,KAAK,MAAQ,KACZ,KAAK,aAAuB,KAC7B,KAAK,iBAAmB,KACxB,KAAK,oBAAsB,IAC/B,CAGO,+BAA+BiC,EACtC,CACI,KAAK,eAAe,MAAMA,EAAOA,CAAK,CAC1C,CAGO,+BAA+BA,EACtC,CACI,KAAK,eAAe,aAAaA,EAAOA,CAAK,CACjD,CAGO,2BAA2BA,EAAiC7B,EACnE,CACI,KAAK,+BAA+B6B,CAAK,EACrC7B,EAAK,OAELA,EAAK,OAAO,aAAa6B,CAAgB,EAIzC7B,EAAK,aAAa6B,CAAgB,CAE1C,CAEA,OAAO,KAAK,CAAE,SAAAvB,EAAU,MAAA/I,EAAO,MAAAuK,EAAQ,CAAE,EACzC,CACI,MAAMC,EAAW,GAAGzB,CAAQ,IAAI/I,CAAK,IAAIuK,CAAK,GAE9C,GAAIE,EAAM,IAAID,CAAQ,EAElB,OAAO,IAAI5C,EAAM6C,EAAM,IAAkBD,CAAQ,CAAC,EAGtD,MAAME,EAAgBC,GAAO,IAAsB5B,CAAQ,EAErD6B,EAAaD,GAAO,IAAkB3K,CAAK,EAC3C6K,EAAmB,IAAIC,GAAsBF,CAAU,EAEvDG,EACAL,aAAyB,WACrB,IAAIM,GAAeH,CAAgB,EACnC,IAAII,GAAaJ,CAAgB,EAG3CE,EAAO,MAAQR,EACf,MAAMxC,EAAegD,EAAO,iBAAiBL,CAAa,EAE1D,OAAAD,EAAM,IAAID,EAAUzC,CAAY,EAEzB,IAAIH,EAAM,CACb,aAAAG,CACJ,CAAC,CACL,CACJ,qKC5wBO,MAAMmD,EACb,CADO,aAEHpN,CAAAA,EAAA,KAAiB,mBAAoD,IAAI,KAEzEA,EAAA,KAAO,eAAe,EACtBA,EAAAA,EAAA,KAAO,oBAAoB,EAC3BA,EAAAA,EAAA,KAAO,YAAY,EAAA,EACnBA,EAAA,KAAO,YAAY,IACnBA,EAAA,KAAO,oBAAoB,EAAA,EAC3BA,EAAA,KAAO,eAAe,EACtBA,EAAAA,EAAA,KAAO,wBAAwB,EAAA,EAC/BA,EAAA,KAAO,aAAa,EAEpBA,EAAAA,EAAA,KAAO,YAAY,GACnBA,EAAA,KAAO,yBAAyB,KAChCA,EAAAA,EAAA,KAAO,gBAAgB,KAAA,EACvBA,EAAA,KAAO,qBAAqB,QAAA,EAC5BA,EAAA,KAAO,uBAAuB,UAC9BA,EAAA,KAAO,yBAAyB,KAChCA,EAAAA,EAAA,KAAO,4BAA4B,KACnCA,EAAAA,EAAA,KAAO,2BAA2B,KAAA,EAClCA,EAAA,KAAO,kBAAkB,QAAA,EACzBA,EAAA,KAAO,iBAAiB,QACxBA,EAAAA,EAAA,KAAO,kBAAkB,UACzBA,EAAA,KAAO,aAAa,KACpBA,EAAAA,EAAA,KAAO,gBAAgB,EAAA,EACvBA,EAAA,KAAO,iBAAiB,CAAA,CAAA,CAMjB,cAAcuI,EACrB,CACI,GAAI,KAAK,iBAAiB,IAAIA,CAAK,EACnC,CACI,QAAQ,KAAK,yEAA0EA,CAAK,EAE5F,MACJ,CACA,MAAM8E,EAA2C,CAC7C,qBAAsB,IAAIhB,EAC1B,MAAO,IAAIA,EACX,WAAY,IAAIiB,EAChB,uBAAwB,IAAIA,EAC5B,kBAAmB,IAAIA,EACvB,aAAc,IAAIA,EAClB,gBAAiB,IAAIA,EACrB,kBAAmB,IAAIA,EACvB,oBAAqB,IAAIA,EACzB,qBAAsB,IAAIA,EAC1B,WAAY,IAAIA,EAChB,UAAW,IAAIA,EACf,UAAW,IAAIjB,EACf,cAAe,CACX,MAAO,CAACkB,EAAGC,IACX,CACI,GAAI,KAAK,WACT,CACI,MAAMf,EAAQ,KAAK,IAAIlE,EAAM,MAAM,GAAKA,EAAM,MAAM,GAAK,CAAC,EACpDkF,EAAO,IAAIC,GAAK,CAClB,KAAMF,EAAM,KAAK,KACjB,MAAO,CACH,SAAU,KAAK,cAAgBf,EAC/B,KAAM,KAAK,eACX,WAAY,WAChB,CACJ,CAAC,EAEDgB,EAAK,MAAM,EAAI,KAAK,KAAKlF,EAAM,MAAM,CAAC,EACtCkF,EAAK,OAAO,IAAI,EAAG,EACnBJ,EAAoB,UAAU,SAASI,CAAI,EAC3C,WAAW,IACX,CACSA,EAAK,WAENA,EAAK,QAAA,CAEb,EAAG,GAAG,CACV,CACJ,CACJ,CACJ,EAEAJ,EAAoB,qBAAqB,SAASA,EAAoB,KAAK,EAC3EA,EAAoB,qBAAqB,SAASA,EAAoB,UAAU,EAChFA,EAAoB,qBAAqB,SAASA,EAAoB,sBAAsB,EAC5FA,EAAoB,qBAAqB,SAASA,EAAoB,iBAAiB,EACvFA,EAAoB,qBAAqB,SAASA,EAAoB,YAAY,EAClFA,EAAoB,qBAAqB,SAASA,EAAoB,eAAe,EACrFA,EAAoB,qBAAqB,SAASA,EAAoB,iBAAiB,EACvFA,EAAoB,qBAAqB,SAASA,EAAoB,mBAAmB,EACzFA,EAAoB,qBAAqB,SAASA,EAAoB,oBAAoB,EAC1FA,EAAoB,qBAAqB,SAASA,EAAoB,UAAU,EAChFA,EAAoB,qBAAqB,SAASA,EAAoB,SAAS,EAC/EA,EAAoB,qBAAqB,SAASA,EAAoB,SAAS,EAE9EA,EAAoB,qBAA6B,OAAS,QAG1DA,EAAoB,qBAA6B,mBAAqB,GACtEA,EAAoB,qBAA6B,UAAY,OAC7DA,EAAoB,qBAA6B,oBAAsB,GAExE9E,EAAM,SAAS8E,EAAoB,oBAAoB,EAEvD9E,EAAM,MAAM,YAAY8E,EAAoB,aAAa,EAEzD,KAAK,iBAAiB,IAAI9E,EAAO8E,CAAmB,CACxD,CAEO,YAAY9E,EACnB,CACS,KAAK,iBAAiB,IAAIA,CAAK,GAGhC,KAAK,cAAcA,CAAK,EAG5B,MAAM8E,EAAsB,KAAK,iBAAiB,IAAI9E,CAAK,EAE3D,GAAI,CAAC8E,EAED,OAEJ9E,EAAM,SAAS8E,EAAoB,oBAAoB,EAEvDA,EAAoB,WAAW,MAAM,EACrCA,EAAoB,uBAAuB,QAC3CA,EAAoB,kBAAkB,MAAM,EAC5CA,EAAoB,aAAa,MAAA,EACjCA,EAAoB,gBAAgB,QACpCA,EAAoB,kBAAkB,MAAM,EAC5CA,EAAoB,oBAAoB,QACxCA,EAAoB,qBAAqB,QACzCA,EAAoB,WAAW,MAAM,EACrCA,EAAoB,UAAU,MAAA,EAE9B,QAASM,EAAMN,EAAoB,MAAM,SAAS,OAAQM,EAAM,EAAGA,IAE/DN,EAAoB,MAAM,SAASM,EAAM,CAAC,EAAE,QAAQ,CAAE,SAAU,GAAM,QAAS,GAAM,cAAe,EAAK,CAAC,EAG9G,MAAMlB,EAAQ,KAAK,IAAIlE,EAAM,MAAM,GAAKA,EAAM,MAAM,GAAK,CAAC,EACpDqF,EAAY,KAAK,UAAYnB,EAgCnC,GA9BI,KAAK,WAEL,KAAK,cAAclE,EAAO8E,EAAqBO,EAAWnB,CAAK,EAG/D,KAAK,WAEL,KAAK,cAAclE,EAAO8E,EAAqBO,CAAS,EAGxD,KAAK,mBAEL,KAAK,sBAAsBrF,EAAO8E,EAAqBO,CAAS,EAGhE,KAAK,cAEL,KAAK,iBAAiBrF,EAAO8E,EAAqBO,CAAS,GAG3D,KAAK,cAAgB,KAAK,oBAE1B,KAAK,6BAA6BrF,EAAO8E,EAAqBO,CAAS,EAGvE,KAAK,uBAEL,KAAK,0BAA0BrF,EAAO8E,EAAqBO,CAAS,EAGpE,KAAK,WAEL,UAAWC,KAASR,EAAoB,UAAU,SAE9CQ,EAAM,OAAS,IACfA,EAAM,GAAK,CAGvB,CAEQ,cAActF,EAAc8E,EAA0CO,EAAmBnB,EACjG,CACI,MAAMxB,EAAW1C,EAAM,SACjBuF,EAAY7C,EAAS,EACrB8C,EAAY9C,EAAS,EACrB+C,EAAQ/C,EAAS,MAEvBoC,EAAoB,WAAW,YAAc,CAAE,MAAOO,EAAW,MAAO,KAAK,eAAgB,EAE7F,QAASlO,EAAI,EAAGiO,EAAMK,EAAM,OAAQtO,EAAIiO,EAAKjO,IAC7C,CACI,MAAMiL,EAAOqD,EAAMtO,CAAC,EACduO,EAAUtD,EAAK,KAAK,OACpBuD,EAAQJ,EAAYnD,EAAK,OACzBwD,EAAQJ,EAAYpD,EAAK,OACzByD,EAAON,EAAaG,EAAUtD,EAAK,EAAKA,EAAK,OAC7C0D,EAAON,EAAaE,EAAUtD,EAAK,EAAKA,EAAK,OAEnD,GAAIA,EAAK,KAAK,OAAS,QAAUA,EAAK,KAAK,SAAW,KAElD,SAGJ,MAAM3J,EAAI,KAAK,IAAIkN,EAAQE,CAAI,EACzBE,EAAI,KAAK,IAAIH,EAAQE,CAAI,EAEzBE,EAAK,KAAK,IAAIvN,EAAG,CAAC,EAClB8E,EAAIwI,EACJE,EAAK,KAAK,IAAIF,EAAG,CAAC,EAClB9O,EAAI,KAAK,KAAK+O,EAAKC,CAAE,EACrBC,EAAK,KAAK,IAAIjP,EAAG,CAAC,EAClBkP,EAAM,KAAK,GAAK,IAGhBC,EAAI,KAAK,MAAMF,EAAKD,EAAKD,IAAO,EAAIzI,EAAItG,EAAE,GAAK,EAErD,GAAIA,IAAM,EAEN,SAGJ,MAAMoP,EAAK,IAAItB,EAEfD,EAAoB,MAAM,SAASuB,CAAE,EAGrC,MAAMC,EAAYrP,EAAI,GAAKiN,EAE3BmC,EAAG,QACE,KAAK,CAAC,EAAG,EAAG,EAAIC,EAAWrP,EAAKqP,EAAY,EAAI,EAAGrP,EAAIqP,EAAW,EAAIA,EAAWrP,EAAKqP,EAAY,CAAE,CAAC,EACrG,KAAK,KAAK,UAAU,EACzBD,EAAG,EAAIV,EACPU,EAAG,EAAIT,EACPS,EAAG,MAAM,EAAIpP,EAGb,IAAIsP,EAAW,EAEXZ,EAAQE,GAAQD,EAAQE,EAGxBS,EAAW,CAACH,EAAK,IAAMD,EAElBR,EAAQE,GAAQD,EAAQE,EAG7BS,EAAW,KAAOJ,EAAMC,GAEnBT,EAAQE,GAAQD,EAAQE,EAG7BS,EAAW,CAACH,EAEPT,EAAQE,GAAQD,EAAQE,EAG7BS,EAAWH,EAENR,IAAUE,GAAQH,EAAQE,EAG/BU,EAAW,GAAKJ,EAEXP,IAAUE,GAAQH,EAAQE,EAG/BU,EAAW,IAAMJ,EAEZR,IAAUE,GAAQD,EAAQE,EAG/BS,EAAW,IAAMJ,EAEZR,IAAUE,GAAQD,EAAQE,IAG/BS,EAAW,GAEfF,EAAG,SAAWE,EAGdF,EAAG,OAAO,EAAGpP,EAAGqP,EAAY,GAAG,EAC1B,KAAK,CAAE,MAAO,EAAU,MAAO,EAAI,CAAC,EACpC,OAAO,CAAE,MAAOjB,EAAW,MAAO,KAAK,eAAgB,CAAC,CACjE,CAGA,MAAMmB,EAAenB,EAAY,EAEjCP,EAAoB,WAAW,QAC1B,OAAOS,EAAYiB,EAAchB,EAAYgB,CAAY,EACzD,OAAOjB,EAAYiB,EAAchB,EAAYgB,CAAY,EACzD,OAAOjB,EAAYiB,EAAchB,EAAYgB,CAAY,EACzD,OAAOjB,EAAYiB,EAAchB,EAAYgB,CAAY,EACzD,OAAA,CACT,CAEQ,0BAA0BxG,EAAc8E,EAA0CO,EAC1F,CAEI,MAAMxD,EADW7B,EAAM,SACA,MAEvB,QAAS7I,EAAI,EAAGiO,EAAMvD,EAAM,OAAQ1K,EAAIiO,EAAKjO,IAC7C,CACI,MAAMiJ,EAAOyB,EAAM1K,CAAC,EACdkJ,EAAaD,EAAK,gBAExB,GAAIC,IAAe,MAAQ,EAAEA,aAAsBC,GAE/C,SAGJ,MAAMmG,EAAmBpG,EAEnBkD,EAAW,IAAI,aAAa,CAAC,EAEnCkD,EAAiB,qBAAqBrG,EAAMmD,EAAU,EAAG,CAAC,EAE1DuB,EAAoB,uBAAuB,KAAK,MAAM,KAAKvB,EAAS,MAAM,EAAG,CAAC,CAAC,CAAC,CACpF,CAEAuB,EAAoB,uBAAuB,OAAO,CAC9C,MAAO,KAAK,uBACZ,MAAOO,CACX,CAAC,CACL,CAEQ,6BAA6BrF,EAAc8E,EAA0CO,EAC7F,CAEI,MAAMxD,EADW7B,EAAM,SACA,MAEvB,QAAS7I,EAAI,EAAGiO,EAAMvD,EAAM,OAAQ1K,EAAIiO,EAAKjO,IAC7C,CACI,MAAMiJ,EAAOyB,EAAM1K,CAAC,EAEpB,GAAI,CAACiJ,EAAK,KAAK,OAEX,SAEJ,MAAMC,EAAaD,EAAK,cAAA,EAExB,GAAIC,IAAe,MAAQ,EAAEA,aAAsBE,GAE/C,SAGJ,MAAMmG,EAAiBrG,EAEjBkD,EAAW,IAAI,aAAamD,EAAe,mBAAmB,EAC9DC,EAAYD,EAAe,UACjC,IAAIE,EAAaF,EAAe,WAIhC,GAFAA,EAAe,qBAAqBtG,EAAM,EAAGsG,EAAe,oBAAqBnD,EAAU,EAAG,CAAC,EAE3F,KAAK,kBAEL,QAASpM,EAAI,EAAGiO,EAAMuB,EAAU,OAAQxP,EAAIiO,EAAKjO,GAAK,EACtD,CACI,MAAM0P,EAAKF,EAAUxP,CAAC,EAAI,EACpB2P,EAAKH,EAAUxP,EAAI,CAAC,EAAI,EACxB4P,EAAKJ,EAAUxP,EAAI,CAAC,EAAI,EAE9B2N,EAAoB,kBAAkB,QACjC,OAAOvB,EAASsD,CAAE,EAAGtD,EAASsD,EAAK,CAAC,CAAC,EACrC,OAAOtD,EAASuD,CAAE,EAAGvD,EAASuD,EAAK,CAAC,CAAC,EACrC,OAAOvD,EAASwD,CAAE,EAAGxD,EAASwD,EAAK,CAAC,CAAC,CAC9C,CAIJ,GAAI,KAAK,cAAgBH,EAAa,EACtC,CACIA,GAAcA,GAAc,GAAK,EACjC,IAAII,EAAQzD,EAASqD,EAAa,CAAC,EAC/BK,EAAQ1D,EAASqD,EAAa,CAAC,EAEnC,QAASzP,EAAI,EAAGiO,EAAMwB,EAAYzP,EAAIiO,EAAKjO,GAAK,EAChD,CACI,MAAMH,EAAIuM,EAASpM,CAAC,EACdgH,EAAIoF,EAASpM,EAAI,CAAC,EAExB2N,EAAoB,aAAa,QAC5B,OAAO9N,EAAGmH,CAAC,EACX,OAAO6I,EAAOC,CAAK,EACxBD,EAAQhQ,EACRiQ,EAAQ9I,CACZ,CACJ,CACJ,CAEA2G,EAAoB,aAAa,OAAO,CAAE,MAAOO,EAAW,MAAO,KAAK,aAAc,CAAC,EACvFP,EAAoB,kBAAkB,OAAO,CAAE,MAAOO,EAAW,MAAO,KAAK,kBAAmB,CAAC,CACrG,CAEA,iBAAiBrF,EAAc8E,EAA0CO,EACzE,CAEI,MAAMxD,EADW7B,EAAM,SACA,MAEvB,QAAS7I,EAAI,EAAGiO,EAAMvD,EAAM,OAAQ1K,EAAIiO,EAAKjO,IAC7C,CACI,MAAMiJ,EAAOyB,EAAM1K,CAAC,EAEpB,GAAI,CAACiJ,EAAK,KAAK,OAEX,SAEJ,MAAMC,EAAaD,EAAK,cAAc,EAEtC,GAAIC,IAAe,MAAQ,EAAEA,aAAsB4C,IAE/C,SAGJ,MAAMiE,EAAqB7G,EAErB8G,EAAKD,EAAmB,oBACxBE,EAAQ,IAAI,aAAaD,CAAE,EAEjCD,EAAmB,qBAAqB9G,EAAM,EAAG+G,EAAIC,EAAO,EAAG,CAAC,EAChEtC,EAAoB,gBAAgB,KAAK,MAAM,KAAKsC,CAAK,CAAC,CAC9D,CAEAtC,EAAoB,gBAAgB,OAAO,CACvC,MAAOO,EAAW,MAAO,KAAK,qBAAsB,MAAO,CAC/D,CAAC,CACL,CAEA,sBAAsBrF,EAAc8E,EAA0CO,EAC9E,CAEIP,EAAoB,kBAAkB,UAAUO,EAAW,KAAK,uBAAwB,CAAC,EAEzF,MAAMjH,EAAS,IAAI2F,GAEnB3F,EAAO,OAAO4B,EAAM,SAAU,EAAI,EAElC8E,EAAoB,kBACf,KAAK1G,EAAO,KAAMA,EAAO,KAAMA,EAAO,WAAYA,EAAO,UAAU,CAAC,EACpE,OAAO,CAAE,MAAOiH,EAAW,MAAO,KAAK,sBAAuB,CAAC,EAEpE,MAAMgC,EAAWjJ,EAAO,SAClBkJ,EAAc,CAACC,EAAoCC,EAAkBC,IAC3E,CACI,GAAIA,EAAQ,EAER,MAAM,IAAI,MAAM,0CAA0C,EAE9D,MAAMC,EAAiB,CACjBC,EAAAA,EAAUtC,EAAY,EAE5B,QAASlO,EAAI,EAAGiO,EAAMmC,EAAgB,OAAQpQ,EAAIiO,EAAKjO,GAAK,EAC5D,CACI,MAAMyQ,EAAKL,EAAgBpQ,CAAC,EACtB0Q,EAAKN,EAAgBpQ,EAAI,CAAC,EAGhC2N,EAAoB,oBAAoB,UAAU,KAAK,wBAAwB,EAC/EA,EAAoB,oBAAoB,WAAW8C,EAAIC,EAAIF,CAAO,EAClE7C,EAAoB,oBAAoB,KAAK,CAAC,EAE9C4C,EAAM,KAAKE,EAAIC,CAAE,CACrB,CAGA/C,EAAoB,qBACf,KAAK4C,CAAK,EACV,KAAK,CACF,MAAO,KAAK,0BACZ,MAAO,EACX,CAAC,EACA,OAAO,CACJ,MAAOrC,EACP,MAAO,KAAK,yBAChB,CAAC,CACT,EAEA,QAASlO,EAAI,EAAGiO,EAAMiC,EAAS,OAAQlQ,EAAIiO,EAAKjO,IAChD,CACI,MAAM2Q,EAAUT,EAASlQ,CAAC,EAE1BmQ,EAAYQ,EAAS,EAAGA,EAAQ,MAAM,CAC1C,CACJ,CAEQ,cAAc9H,EAAc8E,EAA0CO,EAC9E,CAEI,MAAMxD,EADW7B,EAAM,SACA,MAEvB,QAAS7I,EAAI,EAAGiO,EAAMvD,EAAM,OAAQ1K,EAAIiO,EAAKjO,IAC7C,CACI,MAAMiJ,EAAOyB,EAAM1K,CAAC,EAEpB,GAAI,CAACiJ,EAAK,KAAK,OAEX,SAEJ,MAAMC,EAAaD,EAAK,cAAA,EAExB,GAAIC,IAAe,MAAQ,EAAEA,aAAsB0H,IAE/C,SAGJ,MAAMC,EAAiB3H,EACvB,IAAI8G,EAAKa,EAAe,oBACxB,MAAMZ,EAAQ,IAAI,aAAaD,CAAE,EAEjCa,EAAe,qBAAqB5H,EAAM,EAAG+G,EAAIC,EAAO,EAAG,CAAC,EAC5D,IAAIQ,EAAKR,EAAM,CAAC,EACZS,EAAKT,EAAM,CAAC,EACZa,EAAK,EACLC,EAAK,EAET,GAAIF,EAAe,OACnB,CACI,MAAMG,EAAMf,EAAM,CAAC,EACbgB,EAAMhB,EAAM,CAAC,EACbiB,EAAMjB,EAAMD,EAAK,CAAC,EAClBmB,EAAMlB,EAAMD,EAAK,CAAC,EAExBc,EAAKb,EAAMD,EAAK,CAAC,EACjBe,EAAKd,EAAMD,EAAK,CAAC,EAGjBrC,EAAoB,WAAW,OAAO8C,EAAIC,CAAE,EAC5C/C,EAAoB,WAAW,cAAcqD,EAAKC,EAAKC,EAAKC,EAAKL,EAAIC,CAAE,EAGvEpD,EAAoB,UAAU,OAAO8C,EAAIC,CAAE,EAC3C/C,EAAoB,UAAU,OAAOqD,EAAKC,CAAG,EAC7CtD,EAAoB,UAAU,OAAOmD,EAAIC,CAAE,EAC3CpD,EAAoB,UAAU,OAAOuD,EAAKC,CAAG,CACjD,CACAnB,GAAM,EACN,QAASoB,EAAK,EAAGA,EAAKpB,EAAIoB,GAAM,EAChC,CACI,MAAMJ,EAAMf,EAAMmB,CAAE,EACdH,EAAMhB,EAAMmB,EAAK,CAAC,EAClBF,EAAMjB,EAAMmB,EAAK,CAAC,EAClBD,EAAMlB,EAAMmB,EAAK,CAAC,EAExBN,EAAKb,EAAMmB,EAAK,CAAC,EACjBL,EAAKd,EAAMmB,EAAK,CAAC,EAEjBzD,EAAoB,WAAW,OAAO8C,EAAIC,CAAE,EAC5C/C,EAAoB,WAAW,cAAcqD,EAAKC,EAAKC,EAAKC,EAAKL,EAAIC,CAAE,EAGvEpD,EAAoB,UAAU,OAAO8C,EAAIC,CAAE,EAC3C/C,EAAoB,UAAU,OAAOqD,EAAKC,CAAG,EAC7CtD,EAAoB,UAAU,OAAOmD,EAAIC,CAAE,EAC3CpD,EAAoB,UAAU,OAAOuD,EAAKC,CAAG,EAC7CV,EAAKK,EACLJ,EAAKK,CACT,CACJ,CAEApD,EAAoB,WAAW,OAAO,CAAE,MAAOO,EAAW,MAAO,KAAK,eAAgB,CAAC,EACvFP,EAAoB,UAAU,OAAO,CAAE,MAAOO,EAAW,MAAO,KAAK,cAAe,CAAC,CACzF,CAEO,gBAAgBrF,EACvB,CACS,KAAK,iBAAiB,IAAIA,CAAK,GAEhC,QAAQ,KAAK,oFAAsFA,CAAK,EAE5G,MAAM8E,EAAsB,KAAK,iBAAiB,IAAI9E,CAAK,EAEtD8E,IAKL9E,EAAM,MAAM,eAAe8E,EAAoB,aAAa,EAE5DA,EAAoB,qBAAqB,QAAQ,CAAE,cAAe,GAAM,SAAU,GAAM,QAAS,EAAK,CAAC,EACvG,KAAK,iBAAiB,OAAO9E,CAAK,EACtC,CACJ"}