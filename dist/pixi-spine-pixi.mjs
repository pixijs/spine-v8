/*!
 * @pixi/spine-pixi - v2.1.1
 * Compiled Wed, 20 Nov 2024 10:46:59 UTC
 *
 * @pixi/spine-pixi is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2024, PixiJS Team, All Rights Reserved
 */import{Texture as ne,ExtensionType as _,LoaderParserPriority as re,checkExtension as $,DOMAdapter as se,path as Y,TextureSource as oe,extensions as I,Geometry as we,Buffer as ie,BufferUsage as N,Shader as ve,compileHighShaderGlProgram as ye,colorBitGl as ke,generateTextureBatchBitGl as Se,roundPixelsBitGl as Te,compileHighShaderGpuProgram as De,colorBit as Pe,generateTextureBatchBit as Be,roundPixelsBit as Ae,getBatchSamplersUniformGroup as Me,Batcher as _e,Color as Oe,collectAllRenderables as Le,ViewContainer as je,Ticker as z,DEG_TO_RAD as Fe,Container as G,Cache as J,Assets as ae,Graphics as P,Text as Ue}from"pixi.js";import{Texture as Re,TextureFilter as D,TextureWrap as K,BlendMode as H,TextureAtlas as We,SkeletonClipping as le,RegionAttachment as O,MeshAttachment as F,Vector2 as $e,Color as U,Skeleton as de,SkeletonData as ce,AnimationState as Xe,AnimationStateData as Ee,Physics as Ve,ClippingAttachment as he,SkeletonBounds as ue,AtlasAttachmentLoader as Ye,SkeletonBinary as Ie,SkeletonJson as Ne,PathAttachment as ze}from"@esotericsoftware/spine-core";export*from"@esotericsoftware/spine-core";if(typeof window!="undefined"&&window.PIXI){const i=window.require;window.require=e=>{if(i)return i(e);if(e.startsWith("@pixi/")||e.startsWith("pixi.js"))return window.PIXI}}var Ge=Object.defineProperty,He=(i,e,t)=>e in i?Ge(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,pe=(i,e,t)=>(He(i,typeof e!="symbol"?e+"":e,t),t);const ge=class M extends Re{constructor(e){super(e.resource),pe(this,"texture"),this.texture=ne.from(e)}static from(e){return M.textureMap.has(e)?M.textureMap.get(e):new M(e)}setFilters(e,t){const r=this.texture.source.style;r.minFilter=M.toPixiTextureFilter(e),r.magFilter=M.toPixiTextureFilter(t),this.texture.source.autoGenerateMipmaps=M.toPixiMipMap(e),this.texture.source.updateMipmaps()}setWraps(e,t){const r=this.texture.source.style;r.addressModeU=M.toPixiTextureWrap(e),r.addressModeV=M.toPixiTextureWrap(t)}dispose(){this.texture.destroy()}static toPixiMipMap(e){switch(e){case D.Nearest:case D.Linear:return!1;case D.MipMapNearestLinear:case D.MipMapNearestNearest:case D.MipMapLinearLinear:case D.MipMapLinearNearest:return!0;default:throw new Error(`Unknown texture filter: ${String(e)}`)}}static toPixiTextureFilter(e){switch(e){case D.Nearest:case D.MipMapNearestLinear:case D.MipMapNearestNearest:return"nearest";case D.Linear:case D.MipMapLinearLinear:case D.MipMapLinearNearest:return"linear";default:throw new Error(`Unknown texture filter: ${String(e)}`)}}static toPixiTextureWrap(e){switch(e){case K.ClampToEdge:return"clamp-to-edge";case K.MirroredRepeat:return"mirror-repeat";case K.Repeat:return"repeat";default:throw new Error(`Unknown texture wrap: ${String(e)}`)}}static toPixiBlending(e){switch(e){case H.Normal:return"normal";case H.Additive:return"add";case H.Multiply:return"multiply";case H.Screen:return"screen";default:throw new Error(`Unknown blendMode: ${String(e)}`)}}};pe(ge,"textureMap",new Map);let Z=ge;var qe=Object.defineProperty,Qe=Object.defineProperties,Je=Object.getOwnPropertyDescriptors,fe=Object.getOwnPropertySymbols,Ke=Object.prototype.hasOwnProperty,Ze=Object.prototype.propertyIsEnumerable,be=(i,e,t)=>e in i?qe(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,et=(i,e)=>{for(var t in e||(e={}))Ke.call(e,t)&&be(i,t,e[t]);if(fe)for(var t of fe(e))Ze.call(e,t)&&be(i,t,e[t]);return i},tt=(i,e)=>Qe(i,Je(e));const nt={extension:_.Asset,loader:{extension:{type:_.LoadParser,priority:re.Normal,name:"spineTextureAtlasLoader"},test(i){return $(i,".atlas")},async load(i){return await(await se.get().fetch(i)).text()},testParse(i,e){const t=$(e.src,".atlas"),r=typeof i=="string";return Promise.resolve(t&&r)},unload(i){i.dispose()},async parse(i,e,t){const r=e.data||{};let n=Y.dirname(e.src);n&&n.lastIndexOf("/")!==n.length-1&&(n+="/");const s=new We(i);if(r.images instanceof oe||typeof r.images=="string"){const o=r.images;r.images={},r.images[s.pages[0].name]=o}const a=[];for(const o of s.pages){const h=o.name,l=r!=null&&r.images?r.images[h]:void 0;if(l instanceof oe)o.setTexture(Z.from(l));else{const c={src:l!=null?l:Y.normalize([...n.split(Y.sep),h].join(Y.sep)),data:tt(et({},r.imageMetadata),{alphaMode:o.pma?"premultiplied-alpha":"premultiply-alpha-on-upload"})},d=t.load(c).then(p=>{o.setTexture(Z.from(p.source))});a.push(d)}}return await Promise.all(a),s}}};I.add(nt);function rt(i){return Object.prototype.hasOwnProperty.call(i,"bones")}function st(i){return i instanceof Uint8Array}const ot={extension:_.Asset,loader:{extension:{type:_.LoadParser,priority:re.Normal,name:"spineSkeletonLoader"},test(i){return $(i,".skel")},async load(i){const e=await se.get().fetch(i);return new Uint8Array(await e.arrayBuffer())},testParse(i,e){const t=$(e.src,".json")&&rt(i),r=$(e.src,".skel")&&st(i);return Promise.resolve(t||r)}}};I.add(ot);const it=new Float32Array(1),at=new Uint32Array(1);class lt extends we{constructor(){const e=new ie({data:it,label:"attribute-batch-buffer",usage:N.VERTEX|N.COPY_DST,shrinkToFit:!1}),t=new ie({data:at,label:"index-batch-buffer",usage:N.INDEX|N.COPY_DST,shrinkToFit:!1}),r=7*4;super({attributes:{aPosition:{buffer:e,format:"float32x2",stride:r,offset:0},aUV:{buffer:e,format:"float32x2",stride:r,offset:2*4},aColor:{buffer:e,format:"unorm8x4",stride:r,offset:4*4},aDarkColor:{buffer:e,format:"unorm8x4",stride:r,offset:5*4},aTextureIdAndRound:{buffer:e,format:"uint16x2",stride:r,offset:6*4}},indexBuffer:t})}}const dt={name:"color-bit",vertex:{header:`
            @in aDarkColor: vec4<f32>;
            @out vDarkColor: vec4<f32>;
        `,main:`
        vDarkColor = aDarkColor;
        `},fragment:{header:`
            @in vDarkColor: vec4<f32>;
        `,end:`
            
        let alpha = outColor.a * vColor.a;
        let rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;

        finalColor = vec4<f32>(rgb, alpha);

        `}},ct={name:"color-bit",vertex:{header:`
            in vec4 aDarkColor;
            out vec4 vDarkColor;
        `,main:`
            vDarkColor = aDarkColor;
        `},fragment:{header:`
            in vec4 vDarkColor;
        `,end:`
            
        finalColor.a = outColor.a * vColor.a;
        finalColor.rgb = ((outColor.a - 1.0) * vDarkColor.a + 1.0 - outColor.rgb) * vDarkColor.rgb + outColor.rgb * vColor.rgb;
        `}};class ht extends ve{constructor(e){const t=ye({name:"dark-tint-batch",bits:[ke,ct,Se(e),Te]}),r=De({name:"dark-tint-batch",bits:[Pe,dt,Be(e),Ae]});super({glProgram:t,gpuProgram:r,resources:{batchSamplers:Me(e)}})}}var ut=Object.defineProperty,pt=(i,e,t)=>e in i?ut(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,X=(i,e,t)=>(pt(i,typeof e!="symbol"?e+"":e,t),t);let me=null;const Ce=class xe extends _e{constructor(){super(...arguments),X(this,"geometry",new lt),X(this,"shader",me||(me=new ht(this.maxTextures))),X(this,"name",xe.extension.name),X(this,"vertexSize",7)}packAttributes(e,t,r,n,s){const a=s<<16|e.roundPixels&65535,o=e.transform,h=o.a,l=o.b,c=o.c,d=o.d,p=o.tx,m=o.ty,{positions:g,uvs:u}=e,f=e.color,b=(f>>24&255)/255,w=Oe.shared.setValue(e.darkColor).premultiply(b,!0).toPremultiplied(1,!1),v=e.attributeOffset,k=v+e.attributeSize;for(let B=v;B<k;B++){const S=B*2,T=g[S],E=g[S+1];t[n++]=h*T+c*E+p,t[n++]=d*E+l*T+m,t[n++]=u[S],t[n++]=u[S+1],r[n++]=f,r[n++]=w,r[n++]=a}}packQuadAttributes(e,t,r,n,s){const a=e.texture,o=e.transform,h=o.a,l=o.b,c=o.c,d=o.d,p=o.tx,m=o.ty,g=e.bounds,u=g.maxX,f=g.minX,b=g.maxY,w=g.minY,v=a.uvs,k=e.color,B=e.darkColor,S=s<<16|e.roundPixels&65535;t[n+0]=h*f+c*w+p,t[n+1]=d*w+l*f+m,t[n+2]=v.x0,t[n+3]=v.y0,r[n+4]=k,r[n+5]=B,r[n+6]=S,t[n+7]=h*u+c*w+p,t[n+8]=d*w+l*u+m,t[n+9]=v.x1,t[n+10]=v.y1,r[n+11]=k,r[n+12]=B,r[n+13]=S,t[n+14]=h*u+c*b+p,t[n+15]=d*b+l*u+m,t[n+16]=v.x2,t[n+17]=v.y2,r[n+18]=k,r[n+19]=B,r[n+20]=S,t[n+21]=h*f+c*b+p,t[n+22]=d*b+l*f+m,t[n+23]=v.x3,t[n+24]=v.y3,r[n+25]=k,r[n+26]=B,r[n+27]=S}};X(Ce,"extension",{type:[_.Batcher],name:"darkTint"});let gt=Ce;I.add(gt);var ft=Object.defineProperty,bt=(i,e,t)=>e in i?ft(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,x=(i,e,t)=>(bt(i,typeof e!="symbol"?e+"":e,t),t);class mt{constructor(){x(this,"indexOffset",0),x(this,"attributeOffset",0),x(this,"indexSize"),x(this,"attributeSize"),x(this,"batcherName","darkTint"),x(this,"packAsQuad",!1),x(this,"renderable"),x(this,"positions"),x(this,"indices"),x(this,"uvs"),x(this,"roundPixels"),x(this,"data"),x(this,"blendMode"),x(this,"darkTint"),x(this,"texture"),x(this,"transform"),x(this,"_textureId"),x(this,"_attributeStart"),x(this,"_indexStart"),x(this,"_batcher"),x(this,"_batch")}get color(){const e=this.data.color,t=this.renderable.groupColor,r=this.renderable.groupAlpha;let n;const s=e.a*r*255;if(t!==16777215){const a=t>>16&255,o=t>>8&255,h=t&255,l=e.r*h,c=e.g*o,d=e.b*a;n=s<<24|d<<16|c<<8|l}else n=s<<24|e.b*255<<16|e.g*255<<8|e.r*255;return n}get darkColor(){const e=this.data.darkColor;return e.b*255<<16|e.g*255<<8|e.r*255}get groupTransform(){return this.renderable.groupTransform}setData(e,t,r,n){if(this.renderable=e,this.transform=e.groupTransform,this.data=t,t.clipped){const s=t.clippedData;this.indexSize=s.indicesCount,this.attributeSize=s.vertexCount,this.positions=s.vertices,this.indices=s.indices,this.uvs=s.uvs}else this.indexSize=t.indices.length,this.attributeSize=t.vertices.length/2,this.positions=t.vertices,this.indices=t.indices,this.uvs=t.uvs;this.texture=t.texture,this.roundPixels=n,this.blendMode=r,this.batcherName=t.darkTint?"darkTint":"default"}}var Ct=Object.defineProperty,xt=(i,e,t)=>e in i?Ct(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,ee=(i,e,t)=>(xt(i,typeof e!="symbol"?e+"":e,t),t);const wt=new le,vt={0:"normal",1:"add",2:"multiply",3:"screen"};class te{constructor(e){ee(this,"renderer"),ee(this,"gpuSpineData",{}),this.renderer=e}validateRenderable(e){if(e._applyState(),e.spineAttachmentsDirty)return!0;if(e.spineTexturesDirty){const t=e.skeleton.drawOrder,r=this.gpuSpineData[e.uid];for(let n=0,s=t.length;n<s;n++){const a=t[n],o=a.getAttachment();if(o instanceof O||o instanceof F){const h=e._getCachedData(a,o),l=r.slotBatches[h.id],c=h.texture;if(c!==l.texture&&!l._batcher.checkAndUpdateTexture(l,c))return!0}}}return!1}addRenderable(e,t){var r,n,s,a;const o=(r=this.gpuSpineData)[n=e.uid]||(r[n]={slotBatches:{}}),h=this.renderer.renderPipes.batch,l=e.skeleton.drawOrder,c=this.renderer._roundPixels|e._roundPixels;e._applyState();for(let d=0,p=l.length;d<p;d++){const m=l[d],g=m.getAttachment(),u=vt[m.data.blendMode];if(g instanceof O||g instanceof F){const b=e._getCachedData(m,g),w=(s=o.slotBatches)[a=b.id]||(s[a]=new mt);w.setData(e,b,u,c),b.skipRender||h.addToBatch(w,t)}const f=e._slotsObject[m.data.name];if(f){const b=f.container;b.includeInBuild=!0,Le(b,t,this.renderer),b.includeInBuild=!1}}wt.clipEnd()}updateRenderable(e){var t;const r=this.gpuSpineData[e.uid];e._applyState();const n=e.skeleton.drawOrder;for(let s=0,a=n.length;s<a;s++){const o=n[s],h=o.getAttachment();if((h instanceof O||h instanceof F)&&!e._getCachedData(o,h).skipRender){const l=r.slotBatches[e._getCachedData(o,h).id];(t=l._batcher)==null||t.updateElement(l)}}}destroyRenderable(e){this.gpuSpineData[e.uid]=null}destroy(){this.gpuSpineData=null,this.renderer=null}}ee(te,"extension",{type:[_.WebGLPipes,_.WebGPUPipes,_.CanvasPipes],name:"spine"}),I.add(te);var yt=Object.defineProperty,kt=(i,e,t)=>e in i?yt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,y=(i,e,t)=>(kt(i,typeof e!="symbol"?e+"":e,t),t);const q=new $e,St=new U,Tt=new U;de.yDown=!0;const R=new le;class Q extends je{constructor(e){var t;e instanceof ce&&(e={skeletonData:e}),super(),y(this,"batched",!0),y(this,"buildId",0),y(this,"renderPipeId","spine"),y(this,"_didSpineUpdate",!1),y(this,"beforeUpdateWorldTransforms",()=>{}),y(this,"afterUpdateWorldTransforms",()=>{}),y(this,"skeleton"),y(this,"state"),y(this,"skeletonBounds"),y(this,"_debug"),y(this,"_slotsObject",Object.create(null)),y(this,"spineAttachmentsDirty",!0),y(this,"spineTexturesDirty",!0),y(this,"_lastAttachments"),y(this,"_stateChanged",!0),y(this,"attachmentCacheData",[]),y(this,"autoUpdateWarned",!1),y(this,"_autoUpdate",!0);const r=e instanceof ce?e:e.skeletonData;this.skeleton=new de(r),this.state=new Xe(new Ee(r)),this.autoUpdate=(t=e==null?void 0:e.autoUpdate)!=null?t:!0;const n=this.skeleton.slots;for(let s=0;s<n.length;s++)this.attachmentCacheData[s]=Object.create(null);this._updateState(0)}getSlotFromRef(e){let t;if(typeof e=="number"?t=this.skeleton.slots[e]:typeof e=="string"?t=this.skeleton.findSlot(e):t=e,!t)throw new Error(`No slot found with the given slot reference: ${e}`);return t}get debug(){return this._debug}set debug(e){this._debug&&this._debug.unregisterSpine(this),e&&e.registerSpine(this),this._debug=e}get autoUpdate(){return this._autoUpdate}set autoUpdate(e){e?(z.shared.add(this.internalUpdate,this),this.autoUpdateWarned=!1):z.shared.remove(this.internalUpdate,this),this._autoUpdate=e}update(e){this.autoUpdate&&!this.autoUpdateWarned&&(console.warn("You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want."),this.autoUpdateWarned=!0),this.internalUpdate(0,e)}internalUpdate(e,t){this._updateState(t!=null?t:z.shared.deltaMS/1e3)}get bounds(){return this._boundsDirty&&this.updateBounds(),this._bounds}setBonePosition(e,t){const r=e;if(typeof e=="string"&&(e=this.skeleton.findBone(e)),!e)throw Error(`Cant set bone position, bone ${String(r)} not found`);if(q.set(t.x,t.y),e.parent){const n=e.parent.worldToLocal(q);e.x=n.x,e.y=-n.y}else e.x=q.x,e.y=q.y}getBonePosition(e,t){const r=e;return typeof e=="string"&&(e=this.skeleton.findBone(e)),e?(t||(t={x:0,y:0}),t.x=e.worldX,t.y=e.worldY,t):(console.error(`Cant set bone position! Bone ${String(r)} not found`),t)}_updateState(e){this.state.update(e),this.skeleton.update(e),this._stateChanged=!0,this._boundsDirty=!0,this.onViewUpdate()}_applyState(){if(!this._stateChanged)return;this._stateChanged=!1;const{skeleton:e}=this;this.state.apply(e),this.beforeUpdateWorldTransforms(this),e.updateWorldTransform(Ve.update),this.afterUpdateWorldTransforms(this),this.validateAttachments(),this.transformAttachments(),this.updateSlotObjects()}validateAttachments(){const e=this.skeleton.drawOrder,t=this._lastAttachments||(this._lastAttachments=[]);let r=0,n=!1;for(let s=0;s<e.length;s++){const a=e[s].getAttachment();a&&(a!==t[r]&&(n=!0,t[r]=a),r++)}r!==t.length&&(n=!0,t.length=r),this.spineAttachmentsDirty=n}transformAttachments(){var e;const t=this.skeleton.drawOrder;for(let r=0;r<t.length;r++){const n=t[r],s=n.getAttachment();if(s){if(s instanceof F||s instanceof O){const a=this._getCachedData(n,s);s instanceof O?s.computeWorldVertices(n,a.vertices,0,2):s.computeWorldVertices(n,0,s.worldVerticesLength,a.vertices,0,2),a.uvs=s.uvs;const o=n.bone.skeleton.color,h=n.color,l=s.color;a.color.set(o.r*h.r*l.r,o.g*h.g*l.g,o.b*h.b*l.b,o.a*h.a*l.a),a.darkTint=!!n.darkColor,n.darkColor&&a.darkColor.setFromColor(n.darkColor),a.skipRender=a.clipped=!1;const c=((e=s.region)==null?void 0:e.texture.texture)||ne.EMPTY;a.texture!==c&&(a.texture=c,this.spineTexturesDirty=!0),R.isClipping()&&this.updateClippingData(a)}else if(s instanceof he){R.clipStart(n,s);continue}}R.clipEndWithSlot(n)}R.clipEnd()}updateClippingData(e){e.clipped=!0,R.clipTriangles(e.vertices,e.vertices.length,e.indices,e.indices.length,e.uvs,St,Tt,!1);const{clippedVertices:t,clippedTriangles:r}=R,n=t.length/8,s=r.length;e.clippedData||(e.clippedData={vertices:new Float32Array(n*2),uvs:new Float32Array(n*2),vertexCount:n,indices:new Uint16Array(s),indicesCount:s},this.spineAttachmentsDirty=!0);const a=e.clippedData,o=a.vertexCount!==n||s!==a.indicesCount;e.skipRender=n===0,o&&(this.spineAttachmentsDirty=!0,a.vertexCount<n&&(a.vertices=new Float32Array(n*2),a.uvs=new Float32Array(n*2)),a.indices.length<s&&(a.indices=new Uint16Array(s)));const{vertices:h,uvs:l,indices:c}=a;for(let d=0;d<n;d++)h[d*2]=t[d*8],h[d*2+1]=t[d*8+1],l[d*2]=t[d*8+6],l[d*2+1]=t[d*8+7];a.vertexCount=n;for(let d=0;d<c.length;d++)c[d]=r[d];a.indicesCount=s}updateSlotObjects(){for(const e in this._slotsObject){const t=this._slotsObject[e];t&&this.updateSlotObject(t)}}updateSlotObject(e){const{slot:t,container:r}=e;if(r.visible=this.skeleton.drawOrder.includes(t),r.visible){const n=t.bone;r.position.set(n.worldX,n.worldY),r.scale.x=n.getWorldScaleX(),r.scale.y=n.getWorldScaleY(),r.rotation=n.getWorldRotationX()*Fe}}_getCachedData(e,t){return this.attachmentCacheData[e.data.index][t.name]||this.initCachedData(e,t)}initCachedData(e,t){var r,n;let s;return t instanceof O?(s=new Float32Array(8),this.attachmentCacheData[e.data.index][t.name]={id:`${e.data.index}-${t.name}`,vertices:s,clipped:!1,indices:[0,1,2,0,2,3],uvs:t.uvs,color:new U(1,1,1,1),darkColor:new U(0,0,0,0),darkTint:!1,skipRender:!1,texture:(r=t.region)==null?void 0:r.texture.texture}):(s=new Float32Array(t.worldVerticesLength),this.attachmentCacheData[e.data.index][t.name]={id:`${e.data.index}-${t.name}`,vertices:s,clipped:!1,indices:t.triangles,uvs:t.uvs,color:new U(1,1,1,1),darkColor:new U(0,0,0,0),darkTint:!1,skipRender:!1,texture:(n=t.region)==null?void 0:n.texture.texture}),this.attachmentCacheData[e.data.index][t.name]}onViewUpdate(){var e;if(this._didChangeId+=4096,this._boundsDirty=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const t=this.renderGroup||this.parentRenderGroup;t&&t.onChildViewUpdate(this),(e=this.debug)==null||e.renderDebug(this)}addSlotObject(e,t){var r;e=this.getSlotFromRef(e);for(const n in this._slotsObject)((r=this._slotsObject[n])==null?void 0:r.container)===t&&this.removeSlotObject(this._slotsObject[n].slot);this.removeSlotObject(e),t.includeInBuild=!1,this.addChild(t),this._slotsObject[e.data.name]={container:t,slot:e},this.updateSlotObject(this._slotsObject[e.data.name])}removeSlotObject(e){var t,r;let n;if(e instanceof G){for(const s in this._slotsObject)if(((t=this._slotsObject[s])==null?void 0:t.container)===e){this._slotsObject[s]=null,n=e;break}}else{const s=this.getSlotFromRef(e);n=(r=this._slotsObject[s.data.name])==null?void 0:r.container,this._slotsObject[s.data.name]=null}n&&(this.removeChild(n),n.includeInBuild=!0)}getSlotObject(e){return e=this.getSlotFromRef(e),this._slotsObject[e.data.name].container}updateBounds(){this._boundsDirty=!1,this.skeletonBounds||(this.skeletonBounds=new ue);const e=this.skeletonBounds;if(e.update(this.skeleton,!0),e.minX===1/0){this._applyState();const t=this.skeleton.drawOrder,r=this._bounds;r.clear();for(let n=0;n<t.length;n++){const s=t[n],a=s.getAttachment();if(a&&(a instanceof O||a instanceof F)){const o=this._getCachedData(s,a);r.addVertexData(o.vertices,0,o.vertices.length)}}}else this._bounds.minX=e.minX,this._bounds.minY=e.minY,this._bounds.maxX=e.maxX,this._bounds.maxY=e.maxY}addBounds(e){e.addBounds(this.bounds)}destroy(e=!1){super.destroy(e),z.shared.remove(this.internalUpdate,this),this.state.clearListeners(),this.debug=void 0,this.skeleton=null,this.state=null,this._slotsObject=null,this._lastAttachments=null,this.attachmentCacheData=null}skeletonToPixiWorldCoordinates(e){this.worldTransform.apply(e,e)}pixiWorldCoordinatesToSkeleton(e){this.worldTransform.applyInverse(e,e)}pixiWorldCoordinatesToBone(e,t){this.pixiWorldCoordinatesToSkeleton(e),t.parent?t.parent.worldToLocal(e):t.worldToLocal(e)}static from({skeleton:e,atlas:t,scale:r=1}){const n=`${e}-${t}-${r}`;if(J.has(n))return new Q(J.get(n));const s=ae.get(e),a=ae.get(t),o=new Ye(a),h=s instanceof Uint8Array?new Ie(o):new Ne(o);h.scale=r;const l=h.readSkeletonData(s);return J.set(n,l),new Q({skeletonData:l})}}var Dt=Object.defineProperty,Pt=(i,e,t)=>e in i?Dt(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,C=(i,e,t)=>(Pt(i,typeof e!="symbol"?e+"":e,t),t);class Bt{constructor(){C(this,"registeredSpines",new Map),C(this,"drawMeshHull",!0),C(this,"drawMeshTriangles",!0),C(this,"drawBones",!0),C(this,"drawPaths",!0),C(this,"drawBoundingBoxes",!0),C(this,"drawClipping",!0),C(this,"drawRegionAttachments",!0),C(this,"drawEvents",!0),C(this,"lineWidth",1),C(this,"regionAttachmentsColor",30975),C(this,"meshHullColor",30975),C(this,"meshTrianglesColor",16763904),C(this,"clippingPolygonColor",16711935),C(this,"boundingBoxesRectColor",65280),C(this,"boundingBoxesPolygonColor",65280),C(this,"boundingBoxesCircleColor",65280),C(this,"pathsCurveColor",16711680),C(this,"pathsLineColor",16711935),C(this,"skeletonXYColor",16711680),C(this,"bonesColor",61132),C(this,"eventFontSize",24),C(this,"eventFontColor",0)}registerSpine(e){if(this.registeredSpines.has(e)){console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",e);return}const t={parentDebugContainer:new G,bones:new G,skeletonXY:new P,regionAttachmentsShape:new P,meshTrianglesLine:new P,meshHullLine:new P,clippingPolygon:new P,boundingBoxesRect:new P,boundingBoxesCircle:new P,boundingBoxesPolygon:new P,pathsCurve:new P,pathsLine:new P,eventText:new G,eventCallback:{event:(r,n)=>{if(this.drawEvents){const s=Math.abs(e.scale.x||e.scale.y||1),a=new Ue({text:n.data.name,style:{fontSize:this.eventFontSize/s,fill:this.eventFontColor,fontFamily:"monospace"}});a.scale.x=Math.sign(e.scale.x),a.anchor.set(.5),t.eventText.addChild(a),setTimeout(()=>{a.destroyed||a.destroy()},250)}}}};t.parentDebugContainer.addChild(t.bones),t.parentDebugContainer.addChild(t.skeletonXY),t.parentDebugContainer.addChild(t.regionAttachmentsShape),t.parentDebugContainer.addChild(t.meshTrianglesLine),t.parentDebugContainer.addChild(t.meshHullLine),t.parentDebugContainer.addChild(t.clippingPolygon),t.parentDebugContainer.addChild(t.boundingBoxesRect),t.parentDebugContainer.addChild(t.boundingBoxesCircle),t.parentDebugContainer.addChild(t.boundingBoxesPolygon),t.parentDebugContainer.addChild(t.pathsCurve),t.parentDebugContainer.addChild(t.pathsLine),t.parentDebugContainer.addChild(t.eventText),t.parentDebugContainer.zIndex=9999999,t.parentDebugContainer.accessibleChildren=!1,t.parentDebugContainer.eventMode="none",t.parentDebugContainer.interactiveChildren=!1,e.addChild(t.parentDebugContainer),e.state.addListener(t.eventCallback),this.registeredSpines.set(e,t)}renderDebug(e){this.registeredSpines.has(e)||this.registerSpine(e);const t=this.registeredSpines.get(e);if(!t)return;e.addChild(t.parentDebugContainer),t.skeletonXY.clear(),t.regionAttachmentsShape.clear(),t.meshTrianglesLine.clear(),t.meshHullLine.clear(),t.clippingPolygon.clear(),t.boundingBoxesRect.clear(),t.boundingBoxesCircle.clear(),t.boundingBoxesPolygon.clear(),t.pathsCurve.clear(),t.pathsLine.clear();for(let s=t.bones.children.length;s>0;s--)t.bones.children[s-1].destroy({children:!0,texture:!0,textureSource:!0});const r=Math.abs(e.scale.x||e.scale.y||1),n=this.lineWidth/r;if(this.drawBones&&this.drawBonesFunc(e,t,n,r),this.drawPaths&&this.drawPathsFunc(e,t,n),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(e,t,n),this.drawClipping&&this.drawClippingFunc(e,t,n),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(e,t,n),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(e,t,n),this.drawEvents)for(const s of t.eventText.children)s.alpha-=.05,s.y-=2}drawBonesFunc(e,t,r,n){const s=e.skeleton,a=s.x,o=s.y,h=s.bones;t.skeletonXY.strokeStyle={width:r,color:this.skeletonXYColor};for(let c=0,d=h.length;c<d;c++){const p=h[c],m=p.data.length,g=a+p.worldX,u=o+p.worldY,f=a+m*p.a+p.worldX,b=o+m*p.b+p.worldY;if(p.data.name==="root"||p.data.parent===null)continue;const w=Math.abs(g-f),v=Math.abs(u-b),k=Math.pow(w,2),B=v,S=Math.pow(v,2),T=Math.sqrt(k+S),E=Math.pow(T,2),W=Math.PI/180,V=Math.acos((E+S-k)/(2*B*T))||0;if(T===0)continue;const L=new P;t.bones.addChild(L);const j=T/50/n;L.context.poly([0,0,0-j,T-j*3,0,T-j,0+j,T-j*3]).fill(this.bonesColor),L.x=g,L.y=u,L.pivot.y=T;let A=0;g<f&&u<b?A=-V+180*W:g>f&&u<b?A=180*(W+V):g>f&&u>b?A=-V:g<f&&u>b?A=V:u===b&&g<f?A=90*W:u===b&&g>f?A=-90*W:g===f&&u<b?A=180*W:g===f&&u>b&&(A=0),L.rotation=A,L.circle(0,T,j*1.2).fill({color:0,alpha:.6}).stroke({width:r,color:this.skeletonXYColor})}const l=r*3;t.skeletonXY.context.moveTo(a-l,o-l).lineTo(a+l,o+l).moveTo(a+l,o-l).lineTo(a-l,o+l).stroke()}drawRegionAttachmentsFunc(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const o=n[s],h=o.getAttachment();if(h===null||!(h instanceof O))continue;const l=h,c=new Float32Array(8);l.computeWorldVertices(o,c,0,2),t.regionAttachmentsShape.poly(Array.from(c.slice(0,8)))}t.regionAttachmentsShape.stroke({color:this.regionAttachmentsColor,width:r})}drawMeshHullAndMeshTriangles(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const o=n[s];if(!o.bone.active)continue;const h=o.getAttachment();if(h===null||!(h instanceof F))continue;const l=h,c=new Float32Array(l.worldVerticesLength),d=l.triangles;let p=l.hullLength;if(l.computeWorldVertices(o,0,l.worldVerticesLength,c,0,2),this.drawMeshTriangles)for(let m=0,g=d.length;m<g;m+=3){const u=d[m]*2,f=d[m+1]*2,b=d[m+2]*2;t.meshTrianglesLine.context.moveTo(c[u],c[u+1]).lineTo(c[f],c[f+1]).lineTo(c[b],c[b+1])}if(this.drawMeshHull&&p>0){p=(p>>1)*2;let m=c[p-2],g=c[p-1];for(let u=0,f=p;u<f;u+=2){const b=c[u],w=c[u+1];t.meshHullLine.context.moveTo(b,w).lineTo(m,g),m=b,g=w}}}t.meshHullLine.stroke({width:r,color:this.meshHullColor}),t.meshTrianglesLine.stroke({width:r,color:this.meshTrianglesColor})}drawClippingFunc(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const o=n[s];if(!o.bone.active)continue;const h=o.getAttachment();if(h===null||!(h instanceof he))continue;const l=h,c=l.worldVerticesLength,d=new Float32Array(c);l.computeWorldVertices(o,0,c,d,0,2),t.clippingPolygon.poly(Array.from(d))}t.clippingPolygon.stroke({width:r,color:this.clippingPolygonColor,alpha:1})}drawBoundingBoxesFunc(e,t,r){t.boundingBoxesRect.lineStyle(r,this.boundingBoxesRectColor,5);const n=new ue;n.update(e.skeleton,!0),t.boundingBoxesRect.rect(n.minX,n.minY,n.getWidth(),n.getHeight()).stroke({width:r,color:this.boundingBoxesRectColor});const s=n.polygons,a=(o,h,l)=>{if(l<3)throw new Error("Polygon must contain at least 3 vertices");const c=[],d=r*2;for(let p=0,m=o.length;p<m;p+=2){const g=o[p],u=o[p+1];t.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),t.boundingBoxesCircle.drawCircle(g,u,d),t.boundingBoxesCircle.fill(0),c.push(g,u)}t.boundingBoxesPolygon.poly(c).fill({color:this.boundingBoxesPolygonColor,alpha:.1}).stroke({width:r,color:this.boundingBoxesPolygonColor})};for(let o=0,h=s.length;o<h;o++){const l=s[o];a(l,0,l.length)}}drawPathsFunc(e,t,r){const n=e.skeleton.slots;for(let s=0,a=n.length;s<a;s++){const o=n[s];if(!o.bone.active)continue;const h=o.getAttachment();if(h===null||!(h instanceof ze))continue;const l=h;let c=l.worldVerticesLength;const d=new Float32Array(c);l.computeWorldVertices(o,0,c,d,0,2);let p=d[2],m=d[3],g=0,u=0;if(l.closed){const f=d[0],b=d[1],w=d[c-2],v=d[c-1];g=d[c-4],u=d[c-3],t.pathsCurve.moveTo(p,m),t.pathsCurve.bezierCurveTo(f,b,w,v,g,u),t.pathsLine.moveTo(p,m),t.pathsLine.lineTo(f,b),t.pathsLine.moveTo(g,u),t.pathsLine.lineTo(w,v)}c-=4;for(let f=4;f<c;f+=6){const b=d[f],w=d[f+1],v=d[f+2],k=d[f+3];g=d[f+4],u=d[f+5],t.pathsCurve.moveTo(p,m),t.pathsCurve.bezierCurveTo(b,w,v,k,g,u),t.pathsLine.moveTo(p,m),t.pathsLine.lineTo(b,w),t.pathsLine.moveTo(g,u),t.pathsLine.lineTo(v,k),p=g,m=u}}t.pathsCurve.stroke({width:r,color:this.pathsCurveColor}),t.pathsLine.stroke({width:r,color:this.pathsLineColor})}unregisterSpine(e){this.registeredSpines.has(e)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",e);const t=this.registeredSpines.get(e);t&&(e.state.removeListener(t.eventCallback),t.parentDebugContainer.destroy({textureSource:!0,children:!0,texture:!0}),this.registeredSpines.delete(e))}}export{Q as Spine,Bt as SpineDebugRenderer,te as SpinePipe,Z as SpineTexture};
//# sourceMappingURL=pixi-spine-pixi.mjs.map
